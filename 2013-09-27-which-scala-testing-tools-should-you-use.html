<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Which Scala Testing Tools Should You Use?</title><title>Which Scala Testing Tools Should You Use? | HBC Tech</title><meta property="og:title" content="Which Scala Testing Tools Should You Use?"><meta name="author" content="HBC Tech"><meta property="og:locale" content="en_US"><meta name="description" content="By Gilt Senior Software Engineer Lukasz Szwed “Scala testing systems have also stepped out on their own and created some of the most mind-blowing testing tools found in any language.” &ndash;Daniel Hinojosa, author of Testing in Scala At Tuesday’s Dublin Scala Users Group meetup, organized by Gilt, I presented a tech talk on standard test-driven development practices available to Scala developers. These include ScalaTest, specs2, ScalaCheck, and various mocking frameworks. The event was great: we kicked things off with wood-fired pizza and a very good selection of beers. As for my presentation? Well, I noticed that many of you couldn’t make it, so I’ll share some of the highlights. I started things off by introducing ScalaTest and specs2, which share a few things in common: both are written in Scala neither provides a one-size-fits-all testing framework, but are platforms that allow for different styles of testing both offer great support for pending test cases they’re mature and production-ready they’re well-integrated with sbt both borrow ideas from Cucumber&ndash;the first framework that truly showed how business professionals and other non-developers could write feature descriptions without using source code About that last point: Cucumber is written in and for Ruby. For Java, very few tools exist that enable Test-Driven Development (TDD), BDD (Business-Driven Development), DDD (Design-Driven Development), or ATDD (Acceptance Test-Driven Development), much less make those processes fun. Experienced Java programmers know and have decent unit tests for our code&ndash;but working with tests written in JUnit or TestNG is brittle and tedious, and the test code does not look as modern as Scala code does. Also, neither JUnit nor TestNG offers ways for non-programmers to create tests. Writing tests in or specs2 can help you turn old-but-good JUnit/TestNG code into actively used assets and eliminate the need for documentation. And that’s fun! ScalaTest Built by Bill Venners, ScalaTest integrating the best aspects of Cucumber while offering deep integration with JUnit and TestNG and lots of flexibility when it comes to scaling. At Gilt, we have learned that switching contexts between languages and frameworks isn’t always the best or most efficient approach, so we use ScalaTest for all of our tests: unit tests, functional tests, Selenium tests, and performance tests. Even though Play Framework&ndash;which we use and love&ndash;comes with specs2 support by default, we have replaced it with ScalaTest in order to make testing simple and consistent across all of our systems. As Linus Torvalds&ndash;the father of the Linux kernel&ndash;says, “Talk is cheap. Show me the code.” Here is extremely simple test case, written in good-old JUnit style but presented in the ScalaTest framework: import org.scalatest.junit.JUnitSuite"><meta property="og:description" content="By Gilt Senior Software Engineer Lukasz Szwed “Scala testing systems have also stepped out on their own and created some of the most mind-blowing testing tools found in any language.” &ndash;Daniel Hinojosa, author of Testing in Scala At Tuesday’s Dublin Scala Users Group meetup, organized by Gilt, I presented a tech talk on standard test-driven development practices available to Scala developers. These include ScalaTest, specs2, ScalaCheck, and various mocking frameworks. The event was great: we kicked things off with wood-fired pizza and a very good selection of beers. As for my presentation? Well, I noticed that many of you couldn’t make it, so I’ll share some of the highlights. I started things off by introducing ScalaTest and specs2, which share a few things in common: both are written in Scala neither provides a one-size-fits-all testing framework, but are platforms that allow for different styles of testing both offer great support for pending test cases they’re mature and production-ready they’re well-integrated with sbt both borrow ideas from Cucumber&ndash;the first framework that truly showed how business professionals and other non-developers could write feature descriptions without using source code About that last point: Cucumber is written in and for Ruby. For Java, very few tools exist that enable Test-Driven Development (TDD), BDD (Business-Driven Development), DDD (Design-Driven Development), or ATDD (Acceptance Test-Driven Development), much less make those processes fun. Experienced Java programmers know and have decent unit tests for our code&ndash;but working with tests written in JUnit or TestNG is brittle and tedious, and the test code does not look as modern as Scala code does. Also, neither JUnit nor TestNG offers ways for non-programmers to create tests. Writing tests in or specs2 can help you turn old-but-good JUnit/TestNG code into actively used assets and eliminate the need for documentation. And that’s fun! ScalaTest Built by Bill Venners, ScalaTest integrating the best aspects of Cucumber while offering deep integration with JUnit and TestNG and lots of flexibility when it comes to scaling. At Gilt, we have learned that switching contexts between languages and frameworks isn’t always the best or most efficient approach, so we use ScalaTest for all of our tests: unit tests, functional tests, Selenium tests, and performance tests. Even though Play Framework&ndash;which we use and love&ndash;comes with specs2 support by default, we have replaced it with ScalaTest in order to make testing simple and consistent across all of our systems. As Linus Torvalds&ndash;the father of the Linux kernel&ndash;says, “Talk is cheap. Show me the code.” Here is extremely simple test case, written in good-old JUnit style but presented in the ScalaTest framework: import org.scalatest.junit.JUnitSuite"><link rel="canonical" href="https://saksdirect.github.io/hbc-tech-blog/2013-09-27-which-scala-testing-tools-should-you-use.html"><meta property="og:url" content="https://saksdirect.github.io/hbc-tech-blog/2013-09-27-which-scala-testing-tools-should-you-use.html"><meta property="og:site_name" content="HBC Tech"><meta property="og:type" content="article"><meta property="article:published_time" content="2013-09-27T12:37:33-05:00"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@"><meta name="twitter:creator" content="@HBC Tech"><script type="application/ld+json">{"name":null,"description":"By Gilt Senior Software Engineer Lukasz Szwed “Scala testing systems have also stepped out on their own and created some of the most mind-blowing testing tools found in any language.” &ndash;Daniel Hinojosa, author of Testing in Scala At Tuesday’s Dublin Scala Users Group meetup, organized by Gilt, I presented a tech talk on standard test-driven development practices available to Scala developers. These include ScalaTest, specs2, ScalaCheck, and various mocking frameworks. The event was great: we kicked things off with wood-fired pizza and a very good selection of beers. As for my presentation? Well, I noticed that many of you couldn’t make it, so I’ll share some of the highlights. I started things off by introducing ScalaTest and specs2, which share a few things in common: both are written in Scala neither provides a one-size-fits-all testing framework, but are platforms that allow for different styles of testing both offer great support for pending test cases they’re mature and production-ready they’re well-integrated with sbt both borrow ideas from Cucumber&ndash;the first framework that truly showed how business professionals and other non-developers could write feature descriptions without using source code About that last point: Cucumber is written in and for Ruby. For Java, very few tools exist that enable Test-Driven Development (TDD), BDD (Business-Driven Development), DDD (Design-Driven Development), or ATDD (Acceptance Test-Driven Development), much less make those processes fun. Experienced Java programmers know and have decent unit tests for our code&ndash;but working with tests written in JUnit or TestNG is brittle and tedious, and the test code does not look as modern as Scala code does. Also, neither JUnit nor TestNG offers ways for non-programmers to create tests. Writing tests in or specs2 can help you turn old-but-good JUnit/TestNG code into actively used assets and eliminate the need for documentation. And that’s fun! ScalaTest Built by Bill Venners, ScalaTest integrating the best aspects of Cucumber while offering deep integration with JUnit and TestNG and lots of flexibility when it comes to scaling. At Gilt, we have learned that switching contexts between languages and frameworks isn’t always the best or most efficient approach, so we use ScalaTest for all of our tests: unit tests, functional tests, Selenium tests, and performance tests. Even though Play Framework&ndash;which we use and love&ndash;comes with specs2 support by default, we have replaced it with ScalaTest in order to make testing simple and consistent across all of our systems. As Linus Torvalds&ndash;the father of the Linux kernel&ndash;says, “Talk is cheap. Show me the code.” Here is extremely simple test case, written in good-old JUnit style but presented in the ScalaTest framework: import org.scalatest.junit.JUnitSuite","author":{"@type":"Person","name":"HBC Tech"},"@type":"BlogPosting","url":"https://saksdirect.github.io/hbc-tech-blog/2013-09-27-which-scala-testing-tools-should-you-use.html","publisher":null,"image":null,"headline":"Which Scala Testing Tools Should You Use?","dateModified":"2013-09-27T12:37:33-05:00","datePublished":"2013-09-27T12:37:33-05:00","sameAs":null,"mainEntityOfPage":{"@type":"WebPage","@id":"https://saksdirect.github.io/hbc-tech-blog/2013-09-27-which-scala-testing-tools-should-you-use.html"},"@context":"http://schema.org"}</script><link rel="stylesheet" href="https://saksdirect.github.io/hbc-tech-blog/assets/css/main.css"><link rel="canonical" href="https://saksdirect.github.io/hbc-tech-blog/2013-09-27-which-scala-testing-tools-should-you-use.html"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,700" rel="stylesheet"><link rel="shortcut icon" href="https://saksdirect.github.io/hbc-tech-blog/assets/images/favicon.ico"></head><body aria-label="Content"><header id="site-header" class="site-header"><div class="site-header__inner"><a class="site-header__logo" href="https://saksdirect.github.io/hbc-tech-blog/"><svg class="hbc-tech-logo" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 64 52"><use class="hbc-tech-logo__text" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#hbc-tech-logo"></use></svg></a><nav id="menu" class="navigation"><svg class="navigation__menu-icon" xmlns="http://www.w3.org/2000/svg"><path class="bar bar__top" d="M0,3 L30,3"></path><path class="bar bar__cross-1" d="M0,14 L30,14"></path><path class="bar bar__cross-2" d="M0,14 L30,14"></path><path class="bar bar__bottom" d="M0,25 L30,25"></path></svg><menu class="menu"><ul class="link-list"><li class="link-list__link-item"><a href="https://saksdirect.github.io/hbc-tech-blog/" class="link-list__link"><span class="link-list__link-highlight">Insights</span></a></li><li class="link-list__link-item"><a href="https://saksdirect.github.io/hbc-tech-blog/code" class="link-list__link"><span class="link-list__link-highlight">Code</span></a></li><li class="link-list__link-item"><a href="https://saksdirect.github.io/hbc-tech-blog/about" class="link-list__link"><span class="link-list__link-highlight">About</span></a></li><li class="link-list__link-item"><a href="https://saksdirect.github.io/hbc-tech-blog/work-here" class="link-list__link"><span class="link-list__link-highlight">Work Here</span></a></li></ul></menu></nav><search id="header-search" class="header-search"><form class="header-search__form"><input type="text" class="header-search__input" id="header-search-input" placeholder="Search" name="query"></form><svg id="header-search__toggle" class="header-search__svg" xmlns="http://www.w3.org/2000/svg"><path class="path path--left-half" d="M11.4842576,23.9891168 C5.09608476,23.7189967 0,18.4546255 0,12 C0,5.54951437 4.85419801,0.113423154 12.4763811,0.0114091479"></path><path class="path path--right-half" d="M12.5376167,0.0118279089 C18.9155446,0.293025077 24,5.55274344 24,12 C24,18.4701834 17.7604297,24.3112218 11.1896721,23.9909829"></path><path class="path path--handle" d="M20.7485408,20.8914207 L26.8571202,27 L20.7485408,20.8914207"></path></svg><section class="header-search__results" id="header-search__results"></section></search></div></header><section class="content"><article class="article"><header class="article__header article__header--reveal"><h1 class="header-title" title="Which Scala Testing Tools Should You Use?">Which Scala Testing Tools Should You Use?</h1><span id="no-image-placeholder" class="no-image-placeholder"></span> <span class="slug-divider"></span> <span class="article-meta__author"><a class="article-meta__author__link" href="https://saksdirect.github.io/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="article-meta__date">SEP 27, 2013</span></header><section class="article__content article__content--reveal"><div class="article__content__read-time"><span class="read-time" title="Estimated read time"><span class="read-time__text-1">11 min</span> <span class="read-time__text-2">Read</span> <span class="read-time__text-3">Time</span></span></div><div class="article__content__share-buttons"><ul class="share-buttons"><li class="share-buttons__link-item"><a href="https://twitter.com/intent/tweet?text=https://saksdirect.github.io/hbc-tech-blog//2013-09-27-which-scala-testing-tools-should-you-use.html" class="share-buttons__link" title="Share on Twitter" target="_blank"><svg class="hbc-svg-icon" height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon--twitter" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#twitter"></use></svg></a></li><li class="share-buttons__link-item"><a href="https://www.linkedin.com/shareArticle?mini=true&url=https://saksdirect.github.io/hbc-tech-blog/&source=/2013-09-27-which-scala-testing-tools-should-you-use.html&title=Which Scala Testing Tools Should You Use?" class="share-buttons__link" title="Share on Linkedin" target="_blank"><svg height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#linkedin"></use></svg></a></li><li class="share-buttons__link-item"><a href="https://www.facebook.com/sharer/sharer.php?u=https://saksdirect.github.io/hbc-tech-blog//2013-09-27-which-scala-testing-tools-should-you-use.html" class="share-buttons__link" title="Share on Facebook" target="_blank"><svg height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#facebook"></use></svg></a></li><li class="share-buttons__link-item"><a href="https://www.reddit.com/submit?url=https://saksdirect.github.io/hbc-tech-blog//2013-09-27-which-scala-testing-tools-should-you-use.html" class="share-buttons__link" title="Share on Reddit" target="_blank"><svg height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#reddit"></use></svg></a></li></ul></div><div class="article__content__body"><p><span><img alt="image" src="http://media.tumblr.com/ec3c87095fe8a21216c516606afffdcc/tumblr_inline_mtskzebUcv1s17bu5.jpg"></span></p><p><span><strong>By Gilt Senior Software Engineer Lukasz Szwed</strong></span></p><p><span>“</span><span>Scala testing systems have also stepped out on their own and created some of the most mind-blowing testing tools found in any language</span><span>.” &ndash;</span><span>Daniel Hinojosa,</span><span>author of</span><a href="http://shop.oreilly.com/product/0636920022602.do" target="_blank"><em>Testing in Scala</em></a><span></span><span></span><span></span></p><p><span>At Tuesday’s <a href="http://tech.gilt.com/2013/09/25/photos-dublin-scala-users-group-sept-24" target="_blank">Dublin Scala Users Group meetup</a></span><span>, organized by Gilt, I presented a tech talk on standard test-driven development practices available to Scala developers. These include <strong>ScalaTest</strong>, <strong>specs2</strong>, <strong>ScalaCheck</strong>, and various <strong>mocking frameworks</strong>. The event was great: we kicked things off with wood-fired pizza and a very good selection of beers. As for my presentation? Well, I noticed that many of you couldn’t make it, so I’ll share some of the highlights.</span></p><p><span>I started things off by introducing</span><a href="http://scalatest.org/" target="_blank"><span>ScalaTest</span></a><span>and</span><a href="http://etorreborre.github.io/specs2/" target="_blank"><span>specs2</span></a><span>, which share a few things in common:</span></p><ul><li><p><span>both are written in Scala</span></p></li><li><p><span>neither provides a one-size-fits-all testing framework, but are platforms that allow for different styles of testing</span></p></li><li><p><span>both offer great support for pending test cases</span></p></li><li><p><span>they’re mature and production-ready</span></p></li><li><p><span>they’re well-integrated with</span><a href="http://www.scala-sbt.org/0.13.0/docs/Detailed-Topics/Testing" target="_blank"><span>sbt</span></a><span></span></p></li><li><p><span>both borrow ideas from Cucumber&ndash;the first framework that truly showed how business professionals and other non-developers could write feature descriptions without using source code</span></p></li></ul><p><span>About that last point: Cucumber is written in and for Ruby. For Java, very few tools exist that enable Test-Driven Development (TDD), BDD (Business-Driven Development), DDD (Design-Driven Development), or ATDD (Acceptance Test-Driven Development), much less make those processes fun. Experienced Java programmers know and have decent unit tests for our code&ndash;but working with tests written in</span><a href="http://junit.org/" target="_blank"><span>JUnit</span></a><span>or</span><a href="http://testng.org/" target="_blank"><span>TestNG</span></a><span>is brittle and tedious, and the test code does not look as modern as Scala code does. Also, neither JUnit nor TestNG offers ways for non-programmers to create tests.</span></p><p><span>Writing tests in or specs2 can help you turn old-but-good JUnit/TestNG code into actively used assets and eliminate the need for documentation. And that’s fun!</span></p><h2><strong>ScalaTest</strong></h2><p><span>Built by Bill Venners, ScalaTest integrating the best aspects of Cucumber while offering deep integration with JUnit and TestNG and lots of flexibility when it comes to scaling. At Gilt, we have learned that switching contexts between languages and frameworks isn’t always the best or most efficient approach, so we use ScalaTest for all of our tests: unit tests, functional tests, Selenium tests, and performance tests. Even though</span><a href="http://www.playframework.com/documentation/2.1.x/ScalaTest" target="_blank"><span>Play Framework</span></a><span>&ndash;which we use and love&ndash;comes with specs2 support by default, we have replaced it with ScalaTest in order to make testing simple and consistent across all of our systems.</span><span></span></p><p><span>As Linus Torvalds&ndash;the father of the Linux kernel&ndash;says,</span><span>“</span><a href="https://lkml.org/lkml/2000/8/25/132" target="_blank"><span>Talk is cheap. Show me the code</span></a><span>.” Here is extremely simple test case, written in good-old JUnit style but presented in the ScalaTest framework:</span><span></span></p><pre><code class="lang-scala">
import org.scalatest.junit.JUnitSuite

import org.junit.Test

class EmployeeTestJUnit4 extends JUnitSuite {

 @Test def testCreateEmployeeObjectAndProperties() {

   val employee = new Employee("Lukasz", "Szwed")

   assert(employee.firstName === "Lukasz")

 }</code></pre><p>Using ScalaTest to refactor tests written in JUnit requires very little effort. And thanks to ScalaTest JUnitSuite, you can run tests with either the JUnit or ScalaTest framework&ndash;a pretty powerful feature. You can still use JUnit’s assertion (assertEquals, assertTrue, etc.), but can also use the more concise assertion syntax that comes with ScalaTest.</p><p><strong>Special features</strong></p><p><span>In my Tech Talk, I highlighted two of my (and my colleagues’) favorite ScalaTest aspects:</span><a href="http://www.artima.com/docs-scalatest-2.0.M8/#org.scalatest.Matchers" target="_blank"><span>Matchers</span></a><span>and</span><a href="http://www.scalatest.org/getting_started_with_feature_spec" target="_blank"><span>FeatureSpec</span></a><span>. Both give you hundreds of options to verify what you are testing, work more quickly, and structure your tests to fit your own unique specifications.</span></p><p><span>Our tech talk audience loved Matchers, a feature that allows you to write code using domain-specific language (DSL)&ndash;in other words, pure English&ndash;for expressing assertions in tests. In addition to making testing more fun, it also makes source code look better and more modern (and, consequently, is perfectly in line with the whole concept of Scala). Consider this sample test:</span></p><pre><code class="lang-scala">
result should equal (3)
result should === (3) 
result should be (3)   
result shouldEqual 3  
result shouldBe 3
</code></pre><p><span>Instead of:<br></span></p><pre><code class="lang-scala">
assertEquals(3, result)
</code></pre><p>If you’re like me, you want to write your code to be as readable by humans as possible. Matchers will help you achieve this.</p><p><span>After my tech talk, several attendees asked me where to discover more examples of Matchers’s magic. The audience also fell in love with FeatureSpec, which offers a BDD-friendly way of performing tests that are higher-level than unit tests. Here’s an example of a test written with FeatureSpec:</span></p><pre><code class="lang-scala">
import org.scalatest.{Matchers, GivenWhenThen, FeatureSpec}

class FeatureSpecTest1 extends FeatureSpec with GivenWhenThen with Matchers {

 info("As an employee object consumer")
 info("I want to be able to create an employee object")
 info("So I can access the first name and last name")
 info("And get the employee full name when I need it")
 info("And also get the Social Security Number")

 feature("Employee object") {
   scenario("Create an employee object with first and last name") {

     Given("an Employee object is created")
     val employee = new Employee("Lukasz", "Szwed")

     Then("the first name and last name should be set")
     val firstName = employee.firstName
     firstName should be ("Lukasz")

     val lastName = employee.lastName
     lastName should be ("Szwed")

     Then("the full name should be set")
     employee.fullName should be (firstName + " " + lastName)

     Then("the ssn should be set")
     employee.ssn should be ("000-00-0000")
   }
 }
}
</code></pre><p><span>When run with</span><a href="http://www.scala-sbt.org/" target="_blank"><span>sbt</span></a><span>, this test will produce the human readable output in pure English, which is like a feature specification with all of the BDD flavor of Given/When/Then. This makes it easy for non-developers to understand, as the following example shows:</span></p><p><img alt="image" height="261px;" src="https://lh3.googleusercontent.com/g46vuUrZCUcT9C7X794qnKYaUma4pXrsyUMgbvRLDs9jqaUummLHTJiqJ-5yYE_0ZUTLG9CKNMNpzVozH_dDdhRUEuAfr6WSScOxmWLlAekvMMXnRDSzB10UHQ" width="624px;"><span></span></p><p><br><span></span><span></span></p><h2>specs2</h2><p><a href="http://etorreborre.github.io/specs2/" target="_blank"><span>Specs2</span></a><span>is an open source test framework designed to help with writing executable software specifications. Developed by Eric Torreborre, it allows you to draw a clear line between unit tests&ndash;which it calls “unit specifications”&ndash;and full-system tests, which are often called acceptance specifications. Well-written documentation is one of its major advantages.</span></p><p><span>specs2 is evolving in the same direction as ScalaTest and offers a similar end result for the user, but is distinguished by its implementation, structure and design. specs2 tests are asynchronous, and each runs in its thread using a Promise (it works well with</span><a href="http://akka.io/" target="_blank"><span>Akka</span></a><span>, as you might expect). Promises are processes that run on separate threads asynchronously using Actors and send objects&ndash;in this case, an ExecutedResult to one another. From what I’ve seen, there’s nothing else on the market as highly advanced as specs2 for dealing with tests</span><span>.</span></p><p><span id="docs-internal-guid-7df02293-606f-952e-b3dc-1c2800810440">Here’s an example of a simple unit specification in specs2:</span></p><pre><code class="lang-scala">
import org.specs2.mutable._

class EmployeeUnitSpecification extends Specification {

 "An employee" should {
   "return the same first name and last name given to it's constructor" in {
     val employee = new Employee("Lukasz", "Szwed")
     employee.firstName must be("Lukasz")
     employee.lastName must be("Szwed")
   }

   "throw StringIndexOutOfBoundsException if invoking charAt on too short name" in {
     val employee = new Employee("Lukasz", "Szwed")
     employee.lastName.charAt(10) must  throwA[StringIndexOutOfBoundsException]
   }

   "return the full name combined of first name and last name" ! pending
 }
}
</code></pre><p><span>The code above illustrates specs2’s excellent support for pending test cases&ndash;a feature that is one of my favorites, and something that JUnit and TestNG truly lack. A pending test, by the way, is a test that has a name but is not implemented yet, or is partially implemented but not ready for execution. The big advantages of pending tests become more apparent in the design and early implementation stages, when developers typically try to describe system behavior before writing any code. Pending tests are helpful in defining specifications and functionality that need to be implemented in the production code.</span></p><p>Acceptance specifications are similar to test specifications, with this key difference: They separate what a test is expected to do from what actually happens during the test. Consider this example:</p><pre><code class="lang-scala">

import org.specs2._

class EmployeeAcceptanceSpecification extends Specification { def is =
 "An employee should"                                                            ^
   p^
   "return the same first name and last name given to it's constructor"          ! e1^
   "throw StringIndexOutOfBoundsException if invoking charAt on too short name"  ! e2^
   end

 def e1 = {
   val employee = new Employee("Lukasz", "Szwed")
   employee.firstName must be("Lukasz")
   employee.lastName must be("Szwed")
 }

 def e2 = { new Employee("Lukasz", "Szwed").lastName.charAt(10) must throwA[StringIndexOutOfBoundsException] }
}

</code></pre><p><span>In the end, you’ll note, the unit specification and acceptance specification tests look pretty familiar.</span></p><p><span>It’s always good to have options, but if you’re looking for a testing framework in Scala you should choose either ScalaTest or specs2. Because they both integrate so well with sbt, any other test library that attracts interest from the open source community should be integrated with either ScalaTest or specs2 (or both). When writing production code and jumping from project to project, however, you should pick one of them and stick to it.</span><br><span></span></p><h2>ScalaCheck</h2><p><a href="https://github.com/rickynils/scalacheck" target="_blank"><span>ScalaCheck</span></a><span>is a fully automated test generation tool based on the</span><a href="http://www.cse.chalmers.se/%7Erjmh/QuickCheck/" target="_blank"><span>QuickCheck</span></a><span>open source project used in Haskell. ScalaCheck includes test define generators that are responsible for generating test data in ScalaCheck. According to the</span><a href="https://github.com/rickynils/scalacheck/wiki/User-Guide" target="_blank"><span>user guide</span></a><span>:</span></p><blockquote><p><span>“</span><span>a generator can be seen simply as a function that takes some generation parameters, and (maybe) returns a generated value. That is, the type Gen[T] may be thought of as a function of type Gen.Params =&gt; Option[T]. … Conceptually, though, you should think of generators simply as functions, and the combinators in the Gen object can be used to create or modify the behaviour of such generator functions.”</span><span></span></p></blockquote><p><br><span>The true magic comes with forAll, which takes generators and creates universally quantified properties for a test.</span></p><p><span>ScalaCheck is well integrated with both ScalaTest and specs2, which is a critical feature. The following example shows how ScalaCheck can be used with ScalaTest:</span></p><pre><code class="lang-scala">
import org.scalatest.FunSpec

import org.scalatest.prop.GeneratorDrivenPropertyChecks
import org.scalacheck.Gen

class ScalaTestWithScalaCheck extends FunSpec with GeneratorDrivenPropertyChecks {

 val gen1 = Gen.oneOf("Abigail", "Amber", "Bertha", "Cally", "Diana", "Esther", "Frannie", "Texarkana", "Justine")
 val gen2 = Gen.oneOf("Adams", "Valles", "Simons", "Gomez", "Patel", "Mehra", "Groenfeld", "Thatcher", "Greenfield")

 describe("An employee object") {
   it("has valid full name") {
     forAll(gen1, gen2) {
       (firstName: String, lastName: String) =&gt;
         new Employee(firstName, lastName).fullName == firstName.trim() + " " + lastName.trim()
     }
   }
 }

 describe("An employee object should have ssn number") {
   it("has valid random ssn number") {
     forAll((Gen.choose(000, 999), "a"), (Gen.choose(00, 99), "b"), (Gen.choose(0000, 9999), "c")) {
       (a: Int, b: Int, c: Int) =&gt; {
         val ssn = a + "-" + b + "-" + c
         info(ssn)
         new Employee(gen1.sample.get, gen2.sample.get, ssn).ssn === ssn
       }
     }
   }
 }
}

</code></pre><p><span>As the simple example above shows, we can use ScalaCheck to easily create hundreds or even thousands of test properties for a test with the certainty that we’ve also accounted for lots of outlier cases.</span></p><h2>Mocking</h2><p><span>One of my favourite definitions of the word “mock” comes from</span><span>Testing in Scala</span><span>, the book quoted at the beginning of this post. It goes like this: “[Mocking] is analogous to the stand-in opponent during preparation for a political debate. The opponent would likely be a campaign team member, but she will have a set of answers already prepared to debate the candidate who needs to train for the big event.”</span></p><p><span>This brings me to</span><a href="http://easymock.org/%20" target="_blank"><span>EasyMock</span></a><span>,</span><a href="http://code.google.com/p/mockito" target="_blank"><span>Mockito</span></a><span>and</span><a href="http://scalamock.org" target="_blank"><span>ScalaMock</span></a><span>. These testing tools integrate well with Scala and help us to avoid the common problems of over-complexity and excessive dependencies. They also make tests run faster.</span></p><p><span><em><strong>ScalaMock</strong></em>:</span><span>This one deserves special attention because it’s a framework fully written in Scala for Scala developers. It tries to address challenges by “mocking” (in this case, imitating) Scala code. With ScalaMock, you can easily gain full support for polymorphic (type-parameterized) methods, operators (methods with symbolic names), overloaded methods, traits, companion objects, and</span><a href="http://scalamacros.org/future.html" target="_blank"><span>macros</span></a><span>. If you are new to Mocking with Scala, give a try to ScalaMock.</span></p><p><em><strong>EasyMock:</strong></em><span>the first Java Mock Framework. ScalaTest provides</span><a href="http://www.artima.com/docs-scalatest-2.0.M8/#org.scalatest.mock.EasyMockSugar" target="_blank"><span>EasyMockSugar</span></a><span>, which helps to both integrate and simplify the use of EasyMock.</span></p><p><em><strong>Mockito</strong></em><span>: The first of the later-generation mocking frameworks to provide mocking options for concrete Java classes. Both Mockito and EasyMock provide similar functionality, but Mockito has the edge in offering more options&ndash;which might be why developers tend to stick to it and use it even with Scala code. At Gilt we started using Mockito back when we were still a Java shop (we began migrating our services to Scala in 2011). It works well for us, so there is no immediate plan to replace it with ScalaMock.</span></p><h2>Wrap-up</h2><p><span>For me, the most interesting part of the meetup was the discussion about how we are doing testing at Gilt. I’ll share more details on that in an upcoming post. Meantime, stay tuned for the next Scala Tech Talk hosted by Gilt in Dublin. I hope to see you there.</span></p></div><footer class="article__content__footer"><div class="article-tags"><span class="article-tags__tag">Scala</span><span>,</span> <span class="article-tags__tag">ScalaCheck</span><span>,</span> <span class="article-tags__tag">specs2</span><span>,</span> <span class="article-tags__tag">ScalaTest</span><span>,</span> <span class="article-tags__tag">Mockito</span><span>,</span> <span class="article-tags__tag">Daniel Hinojosa</span><span>,</span> <span class="article-tags__tag">Lukasz Szwed</span><span>,</span> <span class="article-tags__tag">Bill Venners</span><span>,</span> <span class="article-tags__tag">JUnit</span><span>,</span> <span class="article-tags__tag">TestNG</span><span>,</span> <span class="article-tags__tag">Java</span><span>,</span> <span class="article-tags__tag">business-driven development</span></div><section class="author-bio"><svg class="author-bio__avatar" height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon hbc-svg-icon--avatar__circle" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#circle"></use><use class="hbc-svg-icon hbc-svg-icon--avatar__head" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#head"></use><use class="hbc-svg-icon hbc-svg-icon--avatar__body" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#body"></use></svg><p><a class="author-bio__link" href="https://saksdirect.github.io/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></p><p class="author-bio__bio">We power the website and mobile experiences for Saks, Saks Off Fifth, Gilt, Lord & Taylor and The Bay.</p></section></footer></section><aside class="recirc"><h2 class="header__title">Recent Insights</h2><span class="slug-divider"></span> <a class="header__view-all-link" href="https://saksdirect.github.io/hbc-tech-blog/categories/index.html">See All</a><div class="recirc__articles"><article class="recirc__articles__item"><section class="snippet"><h1 class="snippet__title"><a href="https://saksdirect.github.io/hbc-tech-blog/2017-12-30-presentations-we-love.html" class="snippet__title__link" title="Presentations we love: 2017">Presentations we love: 2017</a></h1><div class="snippet__meta"><a class="meta__category-link" href="https://saksdirect.github.io/hbc-tech-blog/categories/#presentations">presentations</a> <span class="slug-divider"></span> <span class="meta__author"><a class="meta__author-link" href="https://saksdirect.github.io/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="meta__date">DEC 30, 2017</span></div><a href="https://saksdirect.github.io/hbc-tech-blog/2017-12-30-presentations-we-love.html" class="snippet__excerpt__link" title="Presentations we love: 2017"><p class="snippet__excerpt">2017 was a year of growth and learning at HBC Tech. Our organization embraced new technologies and new ways of building application software.</p></a></section></article><article class="recirc__articles__item"><section class="snippet"><h1 class="snippet__title"><a href="https://saksdirect.github.io/hbc-tech-blog/2017-08-10-midyear-recap.html" class="snippet__title__link" title="HBC Tech Talks: February 2017 through July 2017">HBC Tech Talks: February 2017 through July 2017</a></h1><div class="snippet__meta"><a class="meta__category-link" href="https://saksdirect.github.io/hbc-tech-blog/category/events">events</a> <span class="slug-divider"></span> <span class="meta__author"><a class="meta__author-link" href="https://saksdirect.github.io/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="meta__date">AUG 10, 2017</span></div><a href="https://saksdirect.github.io/hbc-tech-blog/2017-08-10-midyear-recap.html" class="snippet__excerpt__link" title="HBC Tech Talks: February 2017 through July 2017"><p class="snippet__excerpt">We’ve had a busy 2017 at HBC. The great work of our teams has created opportunities to share what we’ve learned with audiences around the world. This year our folks have been on stage in Austin, Sydney, Portland, Seattle, San Diego, Boston, London, Israel and on our home turf in NYC and Dublin. The talks have covered deep learning, design thinking, data streaming and developer experience to name just a...</p></a></section></article><article class="recirc__articles__item"><section class="snippet"><h1 class="snippet__title"><a href="https://saksdirect.github.io/hbc-tech-blog/2017-06-29-open-source-friday.html" class="snippet__title__link" title="Open Source Friday">Open Source Friday</a></h1><div class="snippet__meta"><a class="meta__category-link" href="https://saksdirect.github.io/hbc-tech-blog/category/culture">culture</a> <span class="slug-divider"></span> <span class="meta__author"><a class="meta__author-link" href="https://saksdirect.github.io/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="meta__date">JUN 29, 2017</span></div><a href="https://saksdirect.github.io/hbc-tech-blog/2017-06-29-open-source-friday.html" class="snippet__excerpt__link" title="Open Source Friday"><p class="snippet__excerpt">From the 54 public repos maintained at code.gilt.com to the name of our tech blog (displayed in this tab’s header), open source has been part of our team’s DNA for years. Check out this blog post from 2015 if you’re not convinced.</p></a></section></article><article class="recirc__articles__item"><section class="snippet"><h1 class="snippet__title"><a href="https://saksdirect.github.io/hbc-tech-blog/2017-06-12-hbc-at-qcon.html" class="snippet__title__link" title="Hudson's Bay Company at QCon">Hudson's Bay Company at QCon</a></h1><div class="snippet__meta"><a class="meta__category-link" href="https://saksdirect.github.io/hbc-tech-blog/category/events">events</a> <span class="slug-divider"></span> <span class="meta__author"><a class="meta__author-link" href="https://saksdirect.github.io/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="meta__date">JUN 12, 2017</span></div><a href="https://saksdirect.github.io/hbc-tech-blog/2017-06-12-hbc-at-qcon.html" class="snippet__excerpt__link" title="Hudson's Bay Company at QCon"><p class="snippet__excerpt">Heading to QCon? Don’t miss these two sessions! If you can’t make it, stay tuned here for slides and recordings from the conference.</p></a></section></article></div></aside></article></section><footer class="footer"><svg class="est1670" xmlns="http://www.w3.org/2000/svg"><use class="hbc-tech-logo__use" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#est1670"></use></svg><section class="footer__links"><ul class="social-links social-links__list"><li class="social-links__list-item"><a class="social-links__link" target="_blank" rel="next" href="https://www.linkedin.com/company/hbc_digital/"><svg class="social-links__icon" xmlns="http://www.w3.org/2000/svg"><use class="linkedin" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#linkedin"></use></svg></a></li><li class="social-links__list-item"><a class="social-links__link" target="_blank" rel="next" href="https://twitter.com/hbcdigital/"><svg class="social-links__icon" xmlns="http://www.w3.org/2000/svg"><use class="twitter" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#twitter"></use></svg></a></li><li class="social-links__list-item"><a class="social-links__link" target="_blank" rel="next" href="https://www.instagram.com/hbcdigital"><svg class="social-links__icon" xmlns="http://www.w3.org/2000/svg"><use class="instagram" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#instagram"></use></svg></a></li></ul><p class="copyright">&copy; 2018 HBC Tech</p></section></footer><script type="text/javascript" src="https://saksdirect.github.io/hbc-tech-blog/assets/js/vendor/scrollmagic/ScrollMagic.min.js"></script><script type="text/javascript" src="https://saksdirect.github.io/hbc-tech-blog/assets/js/vendor/jekyll-search-js/fetch.js"></script><script type="text/javascript" src="https://saksdirect.github.io/hbc-tech-blog/assets/js/vendor/jekyll-search-js/search.js"></script><script type="text/javascript" src="https://saksdirect.github.io/hbc-tech-blog/assets/js/main.js"></script></body></html>