<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Five Simple Lisp Tips Guaranteed to Boost Your Productivity</title><title>Five Simple Lisp Tips Guaranteed to Boost Your Productivity | HBC Tech</title><meta property="og:title" content="Five Simple Lisp Tips Guaranteed to Boost Your Productivity"><meta name="author" content="HBC Tech"><meta property="og:locale" content="en_US"><meta name="description" content="Lisp is an interesting language. Its emphasis on functional programming and properties such as homoiconicity make it quite different from other languages. Although it’s not suited for all developers, those who have experienced building large applications in other languages may appreciate the simplicity that Lisp provides. When I ask other developers for their thoughts on Lisp, the most common response I receive is, “Why are there so many brackets?” As it turns out, Lisp’s brackets establish some consistency across the language that allows for some neat code-writing tricks. So neat, in fact, that they can make coding a Zen-like experience. Read these tips and you’ll soon be able to make onlookers wonder how you’re able to make code fly around the screen so quickly and elegantly&ndash;and with just a few keystrokes. Lisp Refresher For those of you who aren’t quite clear on Lisp syntax, here are a few basic things to know: Everything is a list The first element in every list is the “function call position” That’s it! Easy, right? Let me show you a few examples written in Clojure (a dialect of Lisp) to make things more concrete. First, a standard “Hello World” example: (println &quot;Hello World&quot;) In Clojure, you create lists by using rounded parentheses. The first element in this list is println, so we are calling a function called println with a single argument “Hello World”. Next, we create a new function called inc: (defn inc &quot;Define a fn that increments a number by 1&quot; [x] (+ x 1)) The first element (the one in function-call position) calls a special function called defn that allows us to create a new function. The other arguments are: The name of the function we want to define&ndash;in this case, inc A string comment that we can use as a human-readable description of what our function does [x] is a vector of the arguments that our new function will receive The body of our function In this final example, we create a try-catch statement: (try (/ 1 0) (catch ArithmeticException e (println &quot;Kaboom!&quot;)) (finally (println &quot;We’ve recovered!&quot;))) We can start to see from this example how lists can be nested to provide richer programming capabilities. This nesting actually results in a tree structure (which in compilers is referred to as an ‘abstract syntax tree’) that provides the basis for some interesting coding workflows. The Structure of Lisp To illustrate what this abstract syntax tree looks like, let’s draw the try-catch example as a tree:I’ve omitted the “finally” block to keep the illustration compact, but it should be clear now how we can visualize Lisp code as a tree. The workflow tips in this article revolve around making edits to this tree: navigating to parent nodes, moving a branch, removing levels, etc. ***I’ll provide these tips specifically for Vim, but there are equivalents in Emacs as well if you prefer that.*** Without further ado! Tip #1: Give your brackets some color ‘Rainbow Parentheses’ is a plugin for text editors that will change the color of your brackets depending on their depth in a list. This enables you to visually recognize the start and close of a particular list. Once we can visualize this, it becomes much easier to jump between depth levels. In the above gif, the cursor starts inside the println then makes jumps upward to each parent node in the tree (println -&gt; catch -&gt; try). These jumps can be performed with the ParEdit plugin while in normal mode by pressing &quot;(&quot;. Tip #2: Keep your parens balanced There’s nothing worse in Lisp than having unbalanced parentheses&ndash;especially if you have blocks of code that include several levels of nesting. Finding which block is missing a closing bracket can become a nightmare. Fortunately, ParEdit can prevent us from having this problem. Say we have a try-catch-finally block and wish to delete the ‘finally’ clause. In Vim, we can easily remove this entire line when in normal mode by pressing ‘dd’. The problem is that if we do this, we will make our parentheses unbalanced by deleting the closing bracket of the try block (in the above gif, the closing red bracket). The ParEdit plugin solves this by forcing our brackets to always remain balanced. With paredit enabled we can perform ‘dd’ to delete the line and delete everything except for any brackets necessary to maintain balance. Tip #3: Learn motions. Master the brackets! Vim provides motions right out of the box, with no additional plugins needed. The handiest motions for dealing with parentheses are &ldquo;select in&rdquo; and &ldquo;select all.&rdquo; These can perform actions on an entire list in just a few keystrokes. For example, say in our try-catch block we want to return positive infinity instead of print a message. Place the cursor inside the println list, issue a &ldquo;select all,&rdquo; and hit &ldquo;c&rdquo; for &ldquo;change.&rdquo; This will replace the entire println list in just three keystrokes. Note that &ldquo;select in&rdquo; will select everything inside the parentheses, while &ldquo;select all&rdquo; will select everything inside the parentheses (including the parentheses themselves). This command will work with round brackets, curly brackets, square brackets and even quotations, making it useful in other non-Lisp languages as well. Here’s a cheat sheet for using these commands: viw - select in word vi( - select in round bracket vi{ - select in curly bracket vi[ - select in square bracket vi” - select in quote ciw - change in word ci( - change in round bracket ci{ - change in curly bracket ci[ - change in square bracket ci” - change in quote va( - select all round bracket va{ - select all curly bracket va[ - select all square bracket va” - select all quote ca( - change all round bracket ca{ - change all curly bracket ca[ - change all square bracket ca” - change all quote Tip #4: Nest with ease! Say we want to assign the result of our try-catch statement to a variable name. This can be done in four easy steps: Place your cursor on either the opening or closing bracket of the try block (one of the red brackets) Hit &ldquo;v%&rdquo; to select everything up to and including the matching bracket Using the ParEdit plugin hit &lt;Leader&gt;w( to wrap the select text in another set of parentheses Inside the new parentheses, write the code to make the assignment (Optional) In the gif I have done an optional fifth step to re-indent the code by selecting the block and pressing the equal sign. &ldquo;=&rdquo; is a standard Vim command to re-indent. Tip #5: Barf and Slurp! Barfing and slurping are terms used in the ParEdit plugin. These operations depend on the location of your cursor. Barfing will eject (“barf”) either the first or last element of the list where your cursor is placed. Slurping is the opposite: A slurp will find the first element to either the left or right of the list where your cursor is and slurp that element into the list. In our try-catch example, say we create a new function called my-function. We then want to move the try-catch block inside this function so that we can call it later. Naively, we could select the try-catch block, then cut and paste it into the function body. Alternatively, in two keystrokes we can slurp the entire try-catch block into the function body! We can perform the opposite operation by then barfing the try-catch back out. The concept might take a few minutes to sink in, but once you understand these operations you will be able to push code around like a pro. Vim Plugins Here are links for the vim plugins I used in the above demos: Vim Clojure Rainbow Parentheses ParEdit (Lambda bird formation photo by Sigfrid Lundberg)"><meta property="og:description" content="Lisp is an interesting language. Its emphasis on functional programming and properties such as homoiconicity make it quite different from other languages. Although it’s not suited for all developers, those who have experienced building large applications in other languages may appreciate the simplicity that Lisp provides. When I ask other developers for their thoughts on Lisp, the most common response I receive is, “Why are there so many brackets?” As it turns out, Lisp’s brackets establish some consistency across the language that allows for some neat code-writing tricks. So neat, in fact, that they can make coding a Zen-like experience. Read these tips and you’ll soon be able to make onlookers wonder how you’re able to make code fly around the screen so quickly and elegantly&ndash;and with just a few keystrokes. Lisp Refresher For those of you who aren’t quite clear on Lisp syntax, here are a few basic things to know: Everything is a list The first element in every list is the “function call position” That’s it! Easy, right? Let me show you a few examples written in Clojure (a dialect of Lisp) to make things more concrete. First, a standard “Hello World” example: (println &quot;Hello World&quot;) In Clojure, you create lists by using rounded parentheses. The first element in this list is println, so we are calling a function called println with a single argument “Hello World”. Next, we create a new function called inc: (defn inc &quot;Define a fn that increments a number by 1&quot; [x] (+ x 1)) The first element (the one in function-call position) calls a special function called defn that allows us to create a new function. The other arguments are: The name of the function we want to define&ndash;in this case, inc A string comment that we can use as a human-readable description of what our function does [x] is a vector of the arguments that our new function will receive The body of our function In this final example, we create a try-catch statement: (try (/ 1 0) (catch ArithmeticException e (println &quot;Kaboom!&quot;)) (finally (println &quot;We’ve recovered!&quot;))) We can start to see from this example how lists can be nested to provide richer programming capabilities. This nesting actually results in a tree structure (which in compilers is referred to as an ‘abstract syntax tree’) that provides the basis for some interesting coding workflows. The Structure of Lisp To illustrate what this abstract syntax tree looks like, let’s draw the try-catch example as a tree:I’ve omitted the “finally” block to keep the illustration compact, but it should be clear now how we can visualize Lisp code as a tree. The workflow tips in this article revolve around making edits to this tree: navigating to parent nodes, moving a branch, removing levels, etc. ***I’ll provide these tips specifically for Vim, but there are equivalents in Emacs as well if you prefer that.*** Without further ado! Tip #1: Give your brackets some color ‘Rainbow Parentheses’ is a plugin for text editors that will change the color of your brackets depending on their depth in a list. This enables you to visually recognize the start and close of a particular list. Once we can visualize this, it becomes much easier to jump between depth levels. In the above gif, the cursor starts inside the println then makes jumps upward to each parent node in the tree (println -&gt; catch -&gt; try). These jumps can be performed with the ParEdit plugin while in normal mode by pressing &quot;(&quot;. Tip #2: Keep your parens balanced There’s nothing worse in Lisp than having unbalanced parentheses&ndash;especially if you have blocks of code that include several levels of nesting. Finding which block is missing a closing bracket can become a nightmare. Fortunately, ParEdit can prevent us from having this problem. Say we have a try-catch-finally block and wish to delete the ‘finally’ clause. In Vim, we can easily remove this entire line when in normal mode by pressing ‘dd’. The problem is that if we do this, we will make our parentheses unbalanced by deleting the closing bracket of the try block (in the above gif, the closing red bracket). The ParEdit plugin solves this by forcing our brackets to always remain balanced. With paredit enabled we can perform ‘dd’ to delete the line and delete everything except for any brackets necessary to maintain balance. Tip #3: Learn motions. Master the brackets! Vim provides motions right out of the box, with no additional plugins needed. The handiest motions for dealing with parentheses are &ldquo;select in&rdquo; and &ldquo;select all.&rdquo; These can perform actions on an entire list in just a few keystrokes. For example, say in our try-catch block we want to return positive infinity instead of print a message. Place the cursor inside the println list, issue a &ldquo;select all,&rdquo; and hit &ldquo;c&rdquo; for &ldquo;change.&rdquo; This will replace the entire println list in just three keystrokes. Note that &ldquo;select in&rdquo; will select everything inside the parentheses, while &ldquo;select all&rdquo; will select everything inside the parentheses (including the parentheses themselves). This command will work with round brackets, curly brackets, square brackets and even quotations, making it useful in other non-Lisp languages as well. Here’s a cheat sheet for using these commands: viw - select in word vi( - select in round bracket vi{ - select in curly bracket vi[ - select in square bracket vi” - select in quote ciw - change in word ci( - change in round bracket ci{ - change in curly bracket ci[ - change in square bracket ci” - change in quote va( - select all round bracket va{ - select all curly bracket va[ - select all square bracket va” - select all quote ca( - change all round bracket ca{ - change all curly bracket ca[ - change all square bracket ca” - change all quote Tip #4: Nest with ease! Say we want to assign the result of our try-catch statement to a variable name. This can be done in four easy steps: Place your cursor on either the opening or closing bracket of the try block (one of the red brackets) Hit &ldquo;v%&rdquo; to select everything up to and including the matching bracket Using the ParEdit plugin hit &lt;Leader&gt;w( to wrap the select text in another set of parentheses Inside the new parentheses, write the code to make the assignment (Optional) In the gif I have done an optional fifth step to re-indent the code by selecting the block and pressing the equal sign. &ldquo;=&rdquo; is a standard Vim command to re-indent. Tip #5: Barf and Slurp! Barfing and slurping are terms used in the ParEdit plugin. These operations depend on the location of your cursor. Barfing will eject (“barf”) either the first or last element of the list where your cursor is placed. Slurping is the opposite: A slurp will find the first element to either the left or right of the list where your cursor is and slurp that element into the list. In our try-catch example, say we create a new function called my-function. We then want to move the try-catch block inside this function so that we can call it later. Naively, we could select the try-catch block, then cut and paste it into the function body. Alternatively, in two keystrokes we can slurp the entire try-catch block into the function body! We can perform the opposite operation by then barfing the try-catch back out. The concept might take a few minutes to sink in, but once you understand these operations you will be able to push code around like a pro. Vim Plugins Here are links for the vim plugins I used in the above demos: Vim Clojure Rainbow Parentheses ParEdit (Lambda bird formation photo by Sigfrid Lundberg)"><link rel="canonical" href="https://tech.hbc.com/hbc-tech-blog/2014-07-03-five-simple-lisp-tips-guaranteed-to-boost-your.html"><meta property="og:url" content="https://tech.hbc.com/hbc-tech-blog/2014-07-03-five-simple-lisp-tips-guaranteed-to-boost-your.html"><meta property="og:site_name" content="HBC Tech"><meta property="og:type" content="article"><meta property="article:published_time" content="2014-07-03T09:57:00-05:00"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@"><meta name="twitter:creator" content="@HBC Tech"><script type="application/ld+json">{"name":null,"description":"Lisp is an interesting language. Its emphasis on functional programming and properties such as homoiconicity make it quite different from other languages. Although it’s not suited for all developers, those who have experienced building large applications in other languages may appreciate the simplicity that Lisp provides. When I ask other developers for their thoughts on Lisp, the most common response I receive is, “Why are there so many brackets?” As it turns out, Lisp’s brackets establish some consistency across the language that allows for some neat code-writing tricks. So neat, in fact, that they can make coding a Zen-like experience. Read these tips and you’ll soon be able to make onlookers wonder how you’re able to make code fly around the screen so quickly and elegantly&ndash;and with just a few keystrokes. Lisp Refresher For those of you who aren’t quite clear on Lisp syntax, here are a few basic things to know: Everything is a list The first element in every list is the “function call position” That’s it! Easy, right? Let me show you a few examples written in Clojure (a dialect of Lisp) to make things more concrete. First, a standard “Hello World” example: (println &quot;Hello World&quot;) In Clojure, you create lists by using rounded parentheses. The first element in this list is println, so we are calling a function called println with a single argument “Hello World”. Next, we create a new function called inc: (defn inc &quot;Define a fn that increments a number by 1&quot; [x] (+ x 1)) The first element (the one in function-call position) calls a special function called defn that allows us to create a new function. The other arguments are: The name of the function we want to define&ndash;in this case, inc A string comment that we can use as a human-readable description of what our function does [x] is a vector of the arguments that our new function will receive The body of our function In this final example, we create a try-catch statement: (try (/ 1 0) (catch ArithmeticException e (println &quot;Kaboom!&quot;)) (finally (println &quot;We’ve recovered!&quot;))) We can start to see from this example how lists can be nested to provide richer programming capabilities. This nesting actually results in a tree structure (which in compilers is referred to as an ‘abstract syntax tree’) that provides the basis for some interesting coding workflows. The Structure of Lisp To illustrate what this abstract syntax tree looks like, let’s draw the try-catch example as a tree:I’ve omitted the “finally” block to keep the illustration compact, but it should be clear now how we can visualize Lisp code as a tree. The workflow tips in this article revolve around making edits to this tree: navigating to parent nodes, moving a branch, removing levels, etc. ***I’ll provide these tips specifically for Vim, but there are equivalents in Emacs as well if you prefer that.*** Without further ado! Tip #1: Give your brackets some color ‘Rainbow Parentheses’ is a plugin for text editors that will change the color of your brackets depending on their depth in a list. This enables you to visually recognize the start and close of a particular list. Once we can visualize this, it becomes much easier to jump between depth levels. In the above gif, the cursor starts inside the println then makes jumps upward to each parent node in the tree (println -&gt; catch -&gt; try). These jumps can be performed with the ParEdit plugin while in normal mode by pressing &quot;(&quot;. Tip #2: Keep your parens balanced There’s nothing worse in Lisp than having unbalanced parentheses&ndash;especially if you have blocks of code that include several levels of nesting. Finding which block is missing a closing bracket can become a nightmare. Fortunately, ParEdit can prevent us from having this problem. Say we have a try-catch-finally block and wish to delete the ‘finally’ clause. In Vim, we can easily remove this entire line when in normal mode by pressing ‘dd’. The problem is that if we do this, we will make our parentheses unbalanced by deleting the closing bracket of the try block (in the above gif, the closing red bracket). The ParEdit plugin solves this by forcing our brackets to always remain balanced. With paredit enabled we can perform ‘dd’ to delete the line and delete everything except for any brackets necessary to maintain balance. Tip #3: Learn motions. Master the brackets! Vim provides motions right out of the box, with no additional plugins needed. The handiest motions for dealing with parentheses are &ldquo;select in&rdquo; and &ldquo;select all.&rdquo; These can perform actions on an entire list in just a few keystrokes. For example, say in our try-catch block we want to return positive infinity instead of print a message. Place the cursor inside the println list, issue a &ldquo;select all,&rdquo; and hit &ldquo;c&rdquo; for &ldquo;change.&rdquo; This will replace the entire println list in just three keystrokes. Note that &ldquo;select in&rdquo; will select everything inside the parentheses, while &ldquo;select all&rdquo; will select everything inside the parentheses (including the parentheses themselves). This command will work with round brackets, curly brackets, square brackets and even quotations, making it useful in other non-Lisp languages as well. Here’s a cheat sheet for using these commands: viw - select in word vi( - select in round bracket vi{ - select in curly bracket vi[ - select in square bracket vi” - select in quote ciw - change in word ci( - change in round bracket ci{ - change in curly bracket ci[ - change in square bracket ci” - change in quote va( - select all round bracket va{ - select all curly bracket va[ - select all square bracket va” - select all quote ca( - change all round bracket ca{ - change all curly bracket ca[ - change all square bracket ca” - change all quote Tip #4: Nest with ease! Say we want to assign the result of our try-catch statement to a variable name. This can be done in four easy steps: Place your cursor on either the opening or closing bracket of the try block (one of the red brackets) Hit &ldquo;v%&rdquo; to select everything up to and including the matching bracket Using the ParEdit plugin hit &lt;Leader&gt;w( to wrap the select text in another set of parentheses Inside the new parentheses, write the code to make the assignment (Optional) In the gif I have done an optional fifth step to re-indent the code by selecting the block and pressing the equal sign. &ldquo;=&rdquo; is a standard Vim command to re-indent. Tip #5: Barf and Slurp! Barfing and slurping are terms used in the ParEdit plugin. These operations depend on the location of your cursor. Barfing will eject (“barf”) either the first or last element of the list where your cursor is placed. Slurping is the opposite: A slurp will find the first element to either the left or right of the list where your cursor is and slurp that element into the list. In our try-catch example, say we create a new function called my-function. We then want to move the try-catch block inside this function so that we can call it later. Naively, we could select the try-catch block, then cut and paste it into the function body. Alternatively, in two keystrokes we can slurp the entire try-catch block into the function body! We can perform the opposite operation by then barfing the try-catch back out. The concept might take a few minutes to sink in, but once you understand these operations you will be able to push code around like a pro. Vim Plugins Here are links for the vim plugins I used in the above demos: Vim Clojure Rainbow Parentheses ParEdit (Lambda bird formation photo by Sigfrid Lundberg)","author":{"@type":"Person","name":"HBC Tech"},"@type":"BlogPosting","url":"https://tech.hbc.com/hbc-tech-blog/2014-07-03-five-simple-lisp-tips-guaranteed-to-boost-your.html","publisher":null,"image":null,"headline":"Five Simple Lisp Tips Guaranteed to Boost Your Productivity","dateModified":"2014-07-03T09:57:00-05:00","datePublished":"2014-07-03T09:57:00-05:00","sameAs":null,"mainEntityOfPage":{"@type":"WebPage","@id":"https://tech.hbc.com/hbc-tech-blog/2014-07-03-five-simple-lisp-tips-guaranteed-to-boost-your.html"},"@context":"http://schema.org"}</script><link rel="stylesheet" href="https://tech.hbc.com/hbc-tech-blog/assets/css/main.css"><link rel="canonical" href="https://tech.hbc.com/hbc-tech-blog/2014-07-03-five-simple-lisp-tips-guaranteed-to-boost-your.html"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,700" rel="stylesheet"><link rel="shortcut icon" href="https://tech.hbc.com/hbc-tech-blog/assets/images/favicon.ico"></head><body aria-label="Content"><header id="site-header" class="site-header"><div class="site-header__inner"><a class="site-header__logo" href="https://tech.hbc.com/hbc-tech-blog/"><svg class="hbc-tech-logo" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 64 52"><use class="hbc-tech-logo__text" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#hbc-tech-logo"></use></svg></a><nav id="menu" class="navigation"><svg class="navigation__menu-icon" xmlns="http://www.w3.org/2000/svg"><path class="bar bar__top" d="M0,3 L30,3"></path><path class="bar bar__cross-1" d="M0,14 L30,14"></path><path class="bar bar__cross-2" d="M0,14 L30,14"></path><path class="bar bar__bottom" d="M0,25 L30,25"></path></svg><menu class="menu"><ul class="link-list"><li class="link-list__link-item"><a href="https://tech.hbc.com/hbc-tech-blog/" class="link-list__link"><span class="link-list__link-highlight">Insights</span></a></li><li class="link-list__link-item"><a href="https://tech.hbc.com/hbc-tech-blog/code" class="link-list__link"><span class="link-list__link-highlight">Code</span></a></li><li class="link-list__link-item"><a href="https://tech.hbc.com/hbc-tech-blog/about" class="link-list__link"><span class="link-list__link-highlight">About</span></a></li><li class="link-list__link-item"><a href="https://tech.hbc.com/hbc-tech-blog/work-here" class="link-list__link"><span class="link-list__link-highlight">Work Here</span></a></li></ul></menu></nav><search id="header-search" class="header-search"><form class="header-search__form"><input type="text" class="header-search__input" id="header-search-input" placeholder="Search" name="query"></form><svg id="header-search__toggle" class="header-search__svg" xmlns="http://www.w3.org/2000/svg"><path class="path path--left-half" d="M11.4842576,23.9891168 C5.09608476,23.7189967 0,18.4546255 0,12 C0,5.54951437 4.85419801,0.113423154 12.4763811,0.0114091479"></path><path class="path path--right-half" d="M12.5376167,0.0118279089 C18.9155446,0.293025077 24,5.55274344 24,12 C24,18.4701834 17.7604297,24.3112218 11.1896721,23.9909829"></path><path class="path path--handle" d="M20.7485408,20.8914207 L26.8571202,27 L20.7485408,20.8914207"></path><path class="path path--cross-1" d="M3.5 3.5L11.575 11.699 20.26 20.516"></path><path class="path path--cross-2" d="M20.26 3.256L11.848 11.797 3.5 20.272"></path></svg><section class="header-search__results" id="header-search__results"></section></search></div></header><section class="content"><article class="article"><header class="article__header article__header--reveal"><h1 class="header-title" title="Five Simple Lisp Tips Guaranteed to Boost Your Productivity">Five Simple Lisp Tips Guaranteed to Boost Your Productivity</h1><span id="no-image-placeholder" class="no-image-placeholder"></span> <span class="slug-divider"></span> <span class="article-meta__author"><a class="article-meta__author__link" href="https://tech.hbc.com/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="article-meta__date">JUL 3, 2014</span></header><section class="article__content article__content--reveal"><div class="article__content__read-time"><span class="read-time" title="Estimated read time"><span class="read-time__text-1">7 min</span> <span class="read-time__text-2">Read</span> <span class="read-time__text-3">Time</span></span></div><div class="article__content__share-buttons"><ul class="share-buttons"><li class="share-buttons__link-item"><a href="https://twitter.com/intent/tweet?text=https://tech.hbc.com/hbc-tech-blog//2014-07-03-five-simple-lisp-tips-guaranteed-to-boost-your.html" class="share-buttons__link" title="Share on Twitter" target="_blank"><svg class="hbc-svg-icon" height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon--twitter" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#twitter"></use></svg></a></li><li class="share-buttons__link-item"><a href="https://www.linkedin.com/shareArticle?mini=true&url=https://tech.hbc.com/hbc-tech-blog/&source=/2014-07-03-five-simple-lisp-tips-guaranteed-to-boost-your.html&title=Five Simple Lisp Tips Guaranteed to Boost Your Productivity" class="share-buttons__link" title="Share on Linkedin" target="_blank"><svg height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#linkedin"></use></svg></a></li><li class="share-buttons__link-item"><a href="https://www.facebook.com/sharer/sharer.php?u=https://tech.hbc.com/hbc-tech-blog//2014-07-03-five-simple-lisp-tips-guaranteed-to-boost-your.html" class="share-buttons__link" title="Share on Facebook" target="_blank"><svg height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#facebook"></use></svg></a></li><li class="share-buttons__link-item"><a href="https://www.reddit.com/submit?url=https://tech.hbc.com/hbc-tech-blog//2014-07-03-five-simple-lisp-tips-guaranteed-to-boost-your.html" class="share-buttons__link" title="Share on Reddit" target="_blank"><svg height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#reddit"></use></svg></a></li></ul></div><div class="article__content__body"><p><span><span><img alt="image" height="597" src="https://31.media.tumblr.com/33addd3b4f2d7d4949627a414871c915/tumblr_inline_n857iu8hUU1s17bu5.png" width="800"></span></span></p><p><span id="docs-internal-guid-411095e4-fca1-dc7c-4312-3a452649d85c"><span>Lisp is an interesting language. Its emphasis on functional programming and properties such as</span><a href="http://en.wikipedia.org/wiki/Homoiconicity" target="_blank"><span>homoiconicity</span></a><span>make it quite different from other languages. Although it’s not suited for all developers, those who have experienced building large applications in other languages may appreciate the simplicity that Lisp provides.</span></span></p><p><span>When I ask other developers for their thoughts on Lisp, the most common response I receive is, “Why are there so many brackets?” As it turns out, Lisp’s brackets establish some consistency across the language that allows for some neat code-writing tricks. So neat, in fact, that they can make coding a Zen-like experience. Read these tips and you’ll soon be able to make onlookers wonder how you’re able to make code fly around the screen so quickly and elegantly&ndash;and with just a few keystrokes.</span></p><h3>Lisp Refresher</h3><p><span>For those of you who aren’t quite clear on Lisp syntax, here are a few basic things to know:</span></p><ul><li><span>Everything is a list</span></li><li><span>The first element in every list is the “function call position”</span><span></span></li></ul><p><span>That’s it! Easy, right? Let me show you a few examples written in Clojure (a</span><span><a href="http://en.wikipedia.org/wiki/Dialect_%28computing%29" target="_blank">dialect</a> of Lisp) to make things more concrete. First, a standard “Hello World” example:</span></p><pre><code>
(println "Hello World")
</code></pre><p><span><span id="docs-internal-guid-411095e4-fca7-0f5b-e9e0-fb7b69a7d0aa"><span>In Clojure, you create lists by using rounded parentheses. The first element in this list is <code>println,</code> so we are calling a function called <code>println</code> with a single argument “Hello World”.</span></span></span></p><p><span>Next, we create a new function called <code>inc</code>:</span></p><pre><code>
(defn inc
  "Define a fn that increments a number by 1"
  [x] (+ x 1))
</code></pre><p><span>The first element (the one in function-call position) calls a special function called <span><code>defn</code></span> that allows us to create a new function. The other arguments are:</span></p><ul><li><span>The name of the function we want to define&ndash;in this case, <span><span><code>inc</code></span></span></span></li><li><span>A string comment that we can use as a human-readable description of what our function does</span></li><li><span><span><span><span><code><span><span><span><code>[x]</code></span></span></span></code></span></span></span></span><span>is a vector of the arguments that our new function will receive</span></li><li><span>The body of our function</span></li></ul><p><span id="docs-internal-guid-411095e4-fcab-b381-4f55-d67f6b953d6b"><span>In this final example, we create a try-catch statement:</span></span></p><pre><code>
(try
  (/ 1 0)
  (catch ArithmeticException e (println "Kaboom!"))
  (finally (println "We’ve recovered!")))
</code></pre><p><span><span><span id="docs-internal-guid-411095e4-fcab-f87f-22f1-204f5430ad67"><span>We can start to see from this example how lists can be nested to provide richer programming capabilities. This nesting actually results in a tree structure (which in compilers is referred to as an ‘abstract syntax tree’) that provides the basis for some interesting coding workflows.</span></span></span></span></p><h3>The Structure of Lisp</h3><p><span id="docs-internal-guid-411095e4-fcac-d8a2-0f1b-046596b17b67"><span>To illustrate what this abstract syntax tree looks like, let’s draw the try-catch example as a tree:</span></span><span><span id="docs-internal-guid-411095e4-fcad-17f5-ca47-2761d40b278b"><br><img alt="image" height="279px;" src="https://lh3.googleusercontent.com/SOj1WX9Bx-rnpeYRHP_BY7VaW2rWJCBWxiQoP8PGTYDtSMgRN4cgVrWhHpsojE-QVgwMFXuty8uepczZ3kDUDibIlrjafsew8axiW_4EyIa9i_hz7xQK9js8hsWCO32oZA" width="624px;"></span>I’ve omitted the “finally” block to keep the illustration compact, but it should be clear now how we can visualize Lisp code as a tree. The workflow tips in this article revolve around making edits to this tree: navigating to parent nodes, moving a branch, removing levels, etc.</span></p><p><em>***I’ll provide these tips specifically for <strong>Vim</strong>, but there are equivalents in Emacs as well if you prefer that.***</em></p><p><span>Without further ado!</span></p><h3>Tip #1: Give your brackets some color</h3><p><span><img alt="image" height="299px;" src="https://lh5.googleusercontent.com/7ndra0CPa5V8adj7d4SyLGBGKp8pAdP7veqp-sfQUqr3kO71bH5A3Dscw_6-bTVD1g_mH6DW50ABoN91WOwqQtDnTHZJOvHXR9dfGcjZ5yDGTiKkhBY9h7nDe6ykpsjElQ" width="960px;"></span></p><p><span>‘</span><a href="https://github.com/kien/rainbow_parentheses.vim" target="_blank"><span>Rainbow Parentheses</span></a><span>’ is a plugin for text editors that will change the color of your brackets depending on their depth in a list. This enables you to visually recognize the start and close of a particular list. Once we can visualize this, it becomes much easier to jump between depth levels.</span></p><p><span>In the above gif, the cursor starts inside the <span><span><span><code>println</code></span></span></span> then makes jumps upward to each parent node in the tree (<span><span><span><code>println</code></span></span></span> -&gt; <span><span><span><code>catch</code></span></span></span> -&gt; <span><span><span><code>try</code></span></span></span>). These jumps can be performed with the</span><a href="http://www.vim.org/scripts/script.php?script_id=3998" target="_blank"><span>ParEdit</span></a><span>plugin while in normal mode by pressing <span><span><span><code>"("</code></span></span></span>.<span><span><br></span></span></span></p><h3>Tip #2: Keep your parens balanced</h3><p><span><img alt="image" height="299px;" src="https://lh3.googleusercontent.com/yWsr2qEb5E9nxBsPPHFqL7kepm_W_e5ES3QQyXtMAdPmFD82y5ScoR8w-LmUokWtjd7PtSYnxFYnZ2k9leFBOvlq8Rs_9TSUpK_biDXC5ttdWzKmgyMOLVPomkUp6cJ9Mg" width="960px;"></span></p><p><span>There’s nothing worse in Lisp than having unbalanced parentheses&ndash;especially if you have blocks of code that include several levels of nesting. Finding which block is missing a closing bracket can become a nightmare. Fortunately, ParEdit can prevent us from having this problem.</span></p><p><span>Say we have a try-catch-finally block and wish to delete the ‘finally’ clause. In Vim, we can easily remove this entire line when in normal mode by pressing ‘dd’. The problem is that if we do this, we will make our parentheses unbalanced by deleting the closing bracket of the <span><span><span><code>try</code></span></span></span> block (in the above gif, the closing red bracket).</span></p><p><span>The ParEdit plugin solves this by forcing our brackets to always remain balanced. With paredit enabled we can perform ‘dd’ to delete the line and delete everything except for any brackets necessary to maintain balance.</span></p><h3>Tip #3: Learn motions. Master the brackets!</h3><p><span><img alt="image" height="303px;" src="https://lh4.googleusercontent.com/L1YKvylGnz_ghJzVh9lVygmHagSiYAdfzQIZohChvAt87Z4WX6z2JER7wzOTh-J1MUoS1S3B7Z4vJ7pMO6MJTYjZTMm2MU45RA6D0OSDCveMt85JIKrlGrwSff8KZAow8g" width="960px;"></span></p><p><span>Vim provides motions right out of the box, with no additional plugins needed. The handiest motions for dealing with parentheses are &ldquo;select in&rdquo; and &ldquo;select all.&rdquo; <span><span><span></span></span></span>These can perform actions on an entire list in just a few keystrokes. For example, say in our try-catch block we want to return positive infinity instead of print a message. Place the cursor inside the <span><span><span><code>println</code></span></span></span> list, issue a &ldquo;select all,&rdquo; and hit &ldquo;c&rdquo; for &ldquo;change.&rdquo; This will replace the entire <span><span><span><span><code>println</code></span></span></span></span> list in just three keystrokes.</span></p><p><span>Note that &ldquo;select in&rdquo; will select everything inside the parentheses, while &ldquo;select all&rdquo; will select everything inside the parentheses (including the parentheses themselves). This command will work with round brackets, curly brackets, square brackets and even quotations, making it useful in other non-Lisp languages as well.<span><span><br></span></span></span></p><p><span>Here’s a cheat sheet for using these commands:</span></p><ul><li><span>viw - select in word</span></li><li><span>vi( - select in round bracket</span></li><li><span>vi{ - select in curly bracket</span></li><li><span>vi[ - select in square bracket</span></li><li><span>vi” - select in quote</span></li></ul><ul><li><span>ciw - change in word</span></li><li><span>ci( - change in round bracket</span></li><li><span>ci{ - change in curly bracket</span></li><li><span>ci[ - change in square bracket</span></li><li><span>ci” - change in quote</span></li></ul><ul><li><span><span><span></span></span>va( - select all round bracket</span></li><li><span>va{ - select all curly bracket</span></li><li><span>va[ - select all square bracket</span></li><li><span>va” - select all quote</span></li></ul><ul><li><span><span><span></span></span>ca( - change all round bracket</span></li><li><span>ca{ - change all curly bracket</span></li><li><span>ca[ - change all square bracket</span></li><li><span>ca” - change all quote</span></li></ul><h3>Tip #4: Nest with ease!</h3><p><span><img alt="image" height="296px;" src="https://lh6.googleusercontent.com/eJIDP-9t8PrMIvdqM7nae2AaczymznMV4opPliNjMtG7GYZzOsSfMgERtA43Bp0d2z8Zzxim0mCpjFdnlPuMkjo12q_cBkjjqgMa-kFk-PF9zijK5Eu_qzRHpZIb9NAGtg" width="960px;"></span></p><p><span>Say we want to assign the result of our try-catch statement to a variable name. This can be done in four easy steps:</span></p><ol><li><p><span>Place your cursor on either the opening or closing bracket of the try block (one of the red brackets)</span></p></li><li><p><span>Hit &ldquo;v%&rdquo; to select everything up to and including the matching bracket</span></p></li><li><p><span>Using the ParEdit plugin hit &lt;Leader&gt;w( to wrap the select text in another set of parentheses</span></p></li><li><p><span>Inside the new parentheses, write the code to make the assignment</span></p></li><li><p><span>(Optional) In the gif I have done an optional fifth step to re-indent the code by selecting the block and pressing the equal sign. &ldquo;=&rdquo; is a standard</span><a href="http://vim.wikia.com/wiki/Fix_indentation" target="_blank"><span>Vim command to re-indent</span></a><span>.</span></p></li></ol><h3>Tip #5: Barf and Slurp!</h3><p><span><img alt="image" height="299px;" src="https://lh6.googleusercontent.com/uGpQ5yaEXBMrHq8FAqD1Eh4laAlo-cRqQosAfab-hTw2oMzB2_MOTUSrlZ4n6a3T_qeCdySaFvjrEszpPkV9wdpy6R7qNCo1ZnxPFrTo8s9eETnWBchDTsYBorxGNUE6CQ" width="960px;"></span></p><p><span><span><span></span></span>Barfing and slurping are terms used in the ParEdit plugin. These operations depend on the location of your cursor. Barfing will eject (“barf”) either the first or last element of the list where your cursor is placed. Slurping is the opposite: A slurp will find the first element to either the left or right of the list where your cursor is and slurp that element into the list.</span></p><p><span>In our try-catch example, say we create a new function called <span><span><span><span><code>my-function</code></span></span></span></span>. We then want to move the try-catch block inside this function so that we can call it later. Naively, we could select the try-catch block, then cut and paste it into the function body. Alternatively, in two keystrokes we can slurp the entire try-catch block into the function body! We can perform the opposite operation by then barfing the try-catch back out.</span></p><p><span>The concept might take a few minutes to sink in, but once you understand these operations you will be able to push code around like a pro.</span></p><h3>Vim Plugins</h3><p><span>Here are links for the vim plugins I used in the above demos:</span></p><ul><li><a href="https://github.com/guns/vim-clojure-static" target="_blank"><span>Vim Clojure</span></a></li><li><a href="https://github.com/kien/rainbow_parentheses.vim" target="_blank"><span>Rainbow Parentheses</span></a></li><li><a href="https://github.com/vim-scripts/paredit.vim" target="_blank"><span><span id="docs-internal-guid-411095e4-fcae-5c1b-f93f-c577cd1895db"><span>ParEdit</span></span></span></a></li></ul><p><em>(Lambda bird formation photo by <a href="https://www.flickr.com/photos/sigfridlundberg/6659222587/" target="_blank">Sigfrid Lundberg)</a></em></p></div><footer class="article__content__footer"><div class="article-tags"><span class="article-tags__tag">clojure</span><span>,</span> <span class="article-tags__tag">vim</span><span>,</span> <span class="article-tags__tag">lisp</span><span>,</span> <span class="article-tags__tag">Gilt</span><span>,</span> <span class="article-tags__tag">Gilt Groupe</span><span>,</span> <span class="article-tags__tag">Gilt Tech</span><span>,</span> <span class="article-tags__tag">gilttech</span><span>,</span> <span class="article-tags__tag">Scott Thompson</span><span>,</span> <span class="article-tags__tag">functional programming</span><span>,</span> <span class="article-tags__tag">how-to</span><span>,</span> <span class="article-tags__tag">productivity</span><span>,</span> <span class="article-tags__tag">function-call</span><span>,</span> <span class="article-tags__tag">try-catch</span><span>,</span> <span class="article-tags__tag">Lisp syntax</span><span>,</span> <span class="article-tags__tag">Emacs</span><span>,</span> <span class="article-tags__tag">Rainbow Parentheses</span><span>,</span> <span class="article-tags__tag">ParEdit</span><span>,</span> <span class="article-tags__tag">abstract syntax tree</span><span>,</span> <span class="article-tags__tag">try-catch-finally</span><span>,</span> <span class="article-tags__tag">brackets</span><span>,</span> <span class="article-tags__tag">barfing</span><span>,</span> <span class="article-tags__tag">slurping</span></div><section class="author-bio"><svg class="author-bio__avatar" height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon hbc-svg-icon--avatar__circle" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#circle"></use><use class="hbc-svg-icon hbc-svg-icon--avatar__head" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#head"></use><use class="hbc-svg-icon hbc-svg-icon--avatar__body" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#body"></use></svg><p><a class="author-bio__link" href="https://tech.hbc.com/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></p><p class="author-bio__bio">We power the website and mobile experiences for Saks, Saks Off Fifth, Gilt, Lord & Taylor and The Bay.</p></section></footer></section><aside class="recirc"><h2 class="header__title">Recent Insights</h2><span class="slug-divider"></span> <a class="header__view-all-link" href="https://tech.hbc.com/hbc-tech-blog/categories/index.html">See All</a><div class="recirc__articles"><article class="recirc__articles__item"><section class="snippet"><h1 class="snippet__title"><a href="https://tech.hbc.com/hbc-tech-blog/2017-12-30-presentations-we-love.html" class="snippet__title__link" title="Presentations we love: 2017">Presentations we love: 2017</a></h1><div class="snippet__meta"><a class="meta__category-link" href="https://tech.hbc.com/hbc-tech-blog/categories/#presentations">presentations</a> <span class="slug-divider"></span> <span class="meta__author"><a class="meta__author-link" href="https://tech.hbc.com/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="meta__date">DEC 30, 2017</span></div><a href="https://tech.hbc.com/hbc-tech-blog/2017-12-30-presentations-we-love.html" class="snippet__excerpt__link" title="Presentations we love: 2017"><p class="snippet__excerpt">2017 was a year of growth and learning at HBC Tech. Our organization embraced new technologies and new ways of building application software.</p></a></section></article><article class="recirc__articles__item"><section class="snippet"><h1 class="snippet__title"><a href="https://tech.hbc.com/hbc-tech-blog/2017-08-10-midyear-recap.html" class="snippet__title__link" title="HBC Tech Talks: February 2017 through July 2017">HBC Tech Talks: February 2017 through July 2017</a></h1><div class="snippet__meta"><a class="meta__category-link" href="https://tech.hbc.com/hbc-tech-blog/category/events">events</a> <span class="slug-divider"></span> <span class="meta__author"><a class="meta__author-link" href="https://tech.hbc.com/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="meta__date">AUG 10, 2017</span></div><a href="https://tech.hbc.com/hbc-tech-blog/2017-08-10-midyear-recap.html" class="snippet__excerpt__link" title="HBC Tech Talks: February 2017 through July 2017"><p class="snippet__excerpt">We’ve had a busy 2017 at HBC. The great work of our teams has created opportunities to share what we’ve learned with audiences around the world. This year our folks have been on stage in Austin, Sydney, Portland, Seattle, San Diego, Boston, London, Israel and on our home turf in NYC and Dublin. The talks have covered deep learning, design thinking, data streaming and developer experience to name just a...</p></a></section></article><article class="recirc__articles__item"><section class="snippet"><h1 class="snippet__title"><a href="https://tech.hbc.com/hbc-tech-blog/2017-06-29-open-source-friday.html" class="snippet__title__link" title="Open Source Friday">Open Source Friday</a></h1><div class="snippet__meta"><a class="meta__category-link" href="https://tech.hbc.com/hbc-tech-blog/category/culture">culture</a> <span class="slug-divider"></span> <span class="meta__author"><a class="meta__author-link" href="https://tech.hbc.com/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="meta__date">JUN 29, 2017</span></div><a href="https://tech.hbc.com/hbc-tech-blog/2017-06-29-open-source-friday.html" class="snippet__excerpt__link" title="Open Source Friday"><p class="snippet__excerpt">From the 54 public repos maintained at code.gilt.com to the name of our tech blog (displayed in this tab’s header), open source has been part of our team’s DNA for years. Check out this blog post from 2015 if you’re not convinced.</p></a></section></article><article class="recirc__articles__item"><section class="snippet"><h1 class="snippet__title"><a href="https://tech.hbc.com/hbc-tech-blog/2017-06-12-hbc-at-qcon.html" class="snippet__title__link" title="Hudson's Bay Company at QCon">Hudson's Bay Company at QCon</a></h1><div class="snippet__meta"><a class="meta__category-link" href="https://tech.hbc.com/hbc-tech-blog/category/events">events</a> <span class="slug-divider"></span> <span class="meta__author"><a class="meta__author-link" href="https://tech.hbc.com/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="meta__date">JUN 12, 2017</span></div><a href="https://tech.hbc.com/hbc-tech-blog/2017-06-12-hbc-at-qcon.html" class="snippet__excerpt__link" title="Hudson's Bay Company at QCon"><p class="snippet__excerpt">Heading to QCon? Don’t miss these two sessions! If you can’t make it, stay tuned here for slides and recordings from the conference.</p></a></section></article></div></aside></article></section><footer class="footer"><svg class="est1670" xmlns="http://www.w3.org/2000/svg"><use class="hbc-tech-logo__use" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#est1670"></use></svg><section class="footer__links"><ul class="social-links social-links__list"><li class="social-links__list-item"><a class="social-links__link" target="_blank" rel="next" href="https://www.linkedin.com/company/hbc_digital/"><svg class="social-links__icon" xmlns="http://www.w3.org/2000/svg"><use class="linkedin" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#linkedin"></use></svg></a></li><li class="social-links__list-item"><a class="social-links__link" target="_blank" rel="next" href="https://twitter.com/hbcdigital/"><svg class="social-links__icon" xmlns="http://www.w3.org/2000/svg"><use class="twitter" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#twitter"></use></svg></a></li><li class="social-links__list-item"><a class="social-links__link" target="_blank" rel="next" href="https://www.instagram.com/hbcdigital"><svg class="social-links__icon" xmlns="http://www.w3.org/2000/svg"><use class="instagram" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#instagram"></use></svg></a></li></ul><p class="copyright">&copy; 2018 HBC Tech</p></section></footer><script type="text/javascript" src="https://tech.hbc.com/hbc-tech-blog/assets/js/vendor/scrollmagic/ScrollMagic.min.js"></script><script type="text/javascript" src="https://tech.hbc.com/hbc-tech-blog/assets/js/vendor/jekyll-search-js/fetch.js"></script><script type="text/javascript" src="https://tech.hbc.com/hbc-tech-blog/assets/js/vendor/jekyll-search-js/search.js"></script><script type="text/javascript" src="https://tech.hbc.com/hbc-tech-blog/assets/js/main.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-106560024-1', 'auto');
  ga('send', 'pageview');
</script></body></html>