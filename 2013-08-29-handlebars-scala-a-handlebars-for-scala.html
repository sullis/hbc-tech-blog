<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Handlebars.scala: A Handlebars for Scala</title><title>Handlebars.scala: A Handlebars for Scala | HBC Tech</title><meta property="og:title" content="Handlebars.scala: A Handlebars for Scala"><meta name="author" content="HBC Tech"><meta property="og:locale" content="en_US"><meta name="description" content="If you rely on SEO, which really means that you rely on robots, you still want client-side app experiences. Handlebars.scala can help you get there. Handlebars.scala—also known around Gilt Tech as Scandlebars, and sometimes Scandalbars—is a Scala implementation of Handlebars: an extension to and superset of the Mustache templating language. It began as an attempt to learn Scala and to experiment with Scala’s Parser Combinators in order to get Handlebars.js templates working in Scala. These days, it forms a critical part of our stack. The Genesis of Handlebars.scala At Gilt, we rely on SEO for a not-insignificant amount of revenue. This means that, at some point, a robot/crawler makes a request against Gilt’s server, and the server has to return HTML. This is how most web pages have been made. In recent years, the paradigm has shifted toward web applications that use client-side template rendering techniques—i.e., single-page apps. These applications are faster than the old technologies allowed, and offer a snappier user experience. The idea behind a single-page app is that you can offload much of the HTML rendering to the client—and you do that through a templating language. Handlebars is one of those templating languages. At Gilt, we were trying to solve two problems: to render HTML pages server-side, but also get rich client-side rendering—a “best of both worlds” scenario to address the client-server disparity, and create a way to easily share UI pieces as a JVM library. We had experience with server-side templating engines like Java Server Pages (JSP), which has its own nuances, as well as client-side, JavaScript templating engines like Handlebars. With both of these, you end up duplicating logic—and our goal was to economize on server-side rendering and reduce the duplication. Our question: How can we make server-side rendering low-barrier enough without duplicating too much of our efforts in client-side rendering? We Tried Mustache With this question in mind, we checked out Mustache. A logic-less templating language, Mustache offers a considerable benefit: It’s language-agnostic and offers several implementations for all programming languages, including Scala. After experimenting with Mustache, however, our UI Architecture team realized that it’s really terse. Because of its logic-lessness, Mustache is kind of a pain in the ass to write (or can be, for something as large as an ecommerce site with millions of members). After playing around with Mustache, Eric and the team were drawn to Handlebars: a superset of Mustache created by Tilde co-founder Yehuda Katz. Handlebars is very similar to Mustache, but offers a variety of extras—namely, path lookups and helper functions. It also can be pre-compiled into JavaScript. Handlebars is a crucial component of Ember.js, which Yehuda also created. Our issue with Handlebars was that we needed it to run on the JVM. When I shared this info with Yehuda’s colleague, Tilde co-founder Tom Dale, after a NYC.JS meetup, he suggested that we try out Rhino—a JavaScript interpreter written in Java. At the time, Gilt Senior Engineer Kevan Davis was trying to figure out how to run Handlebars and Rhino, and made some progress with it, but the setup was clumsy because Rhino is clumsy. “Maybe I’ll just write Handlebars in Scala,” I finally said to Tom. We were at a bar at the time, and I was a bit tipsy, but there was a “yeah, sure, do that” vibe to our conversation. The Scandal of Scandlebars: I Didn’t Actually Know Scala Yet The problem with “just writing Handlebars in Scala” was that I hadn’t messed around with Scala much. Handlebars.scala was my first Scala project. Developing it was something of an excuse to play with the language and learn it by doing. Whatever works, right? The Scala standard library includes Parser Combinators: a functional programming method to describe grammars for language. I learned how to use Parser Combinators, and how to build parsers, by studying the source code of Scalate (a set of templating languages in Scala, including Mustache). This, plus help from the denizens of Gilt’s Scala 2.9.1 chat room, helped me to create Handlebars.scala. Handlebars’ preference for JavaScript (a dynamically typed, prototype-based language with first-class functions) made writing it in Scala (a statically-typed, hybrid-oriented language) pretty interesting from a bridging-concepts perspective. There’s just all kinds of syntactic quirks with Scala—for example, [Option] and how to make Option—or any monad—work. In developing Handlebars.scala I faced a number of philosophical questions: How do you write idiomatic Scala and still have it make sense? How should Options work? How does the collection library work? How can you leverage case and pattern matching so that you can achieve what you want in Handlebars by using Scala that you’re already familiar with (the idea being that any Scala object should be able to fit into a Handlebars template)? How Handlebars.scala Works I think the key thing that makes Handlebars.scala work is the idea of view models. On the Scala side, in our server, are intelligent, intermediary layers that we can use to render a Scala/Handlebars template or serialized into JSON in order to render them using Handlebars.js. Here’s an example of the apply method of a Handlebars instance, which should be familiar to Scala fans. Apply takes an optional second argument: a Map of helper functions. The signature for apply looks like this: def apply[T](context: T, helpers: Map[String,Helper[T]] = Map.empty[String,Helper[T]]) A few things to note when using Handlebars.scala: Implicit conversions will not work in a template. Because Handlebars.scala makes heavy use of reflection. Bummer, I know. This leads me to… …Handlebars.scala makes heavy use of reflection. This means that there could be unexpected behavior. Method overloading will behave in bizarre ways. There is likely a performance penalty. I’m not sophisticated enough in the arts of the JVM to know the implications of this. How does Handlebars.scala perform? We’ve been using Scandlebars in production, and it’s become a crucial part of our rendering stack. We use it wherever we have a user interface that needs to be represented both the server and the client. Handlebars.scala gives us this choice to render it immediately or at a later date. Some specific examples of Handlebars.scala at Gilt: Our new unified nav (built entirely with Handlebars.scala) We have lots of small applications that don’t all use the same technologies, but we need them to be able to share a user interface as a library. Scandlebars enables us to make these HTML pieces as a library Our product detail pages Search With those last two items, the idea was that the same template we use to render a product on a server can be used to render it on the client. This reduces duplication by a not-inconsequential amount. What the client can do is say, “I know how to render this thing. Now, I know I’m not a robot—I’m a user using JavaScript—so instead of going back to the server for an HTML roundtrip, I can just go to the JSON.” The client-side app experience feels a lot faster with Handlebars.scala. We started to benchmark its performance and tried to find bottlenecks in rendering. Handlebars.scala uses a lot of reflection, so that can sometimes be a bit tricky in Scala or another statically-typed language. But overall, I think it performs pretty well. There’s always going to be an upper bound to its performance because it uses reflection. One key question I haven’t answered yet is this: When you use futures in Scala and Akka, and a Handlebars.scala template resolves that future, how do you organize your code before putting it into Handlebars.scala and make your data easily accessible through Handlebars.scala? Until I have a sure answer to that question, I don’t advise resolving futures inside of a template. Then we started trying to figure out, we have the ability to make an AST (abstract syntax stream) out of a template file. Now how do you take data and render a template. Need some way for the tree to be filled in. It raised a bunch of questions The Future of Handlebars.scala Gilt Software Engineer Chris “Chicks” Hicks and I have started working on the next version of Handlebars.scala—the idea being that Handlebars.js 1.0 has been released fairly recently, and now we want Handlebars.scala to meet it in terms of almost-compatibility. A key concern is how we can make using Handlebars.scala balance between feeling like the JavaScript-Handlebars but just as comfortable for Scala developers. If Handlebars.scala is too much like JavaScript, it won’t fit with the programming paradigm, but if it’s too much like Scala, then it will feel like it deviates too much from its original implementation. I have a few ideas: Make usability improvements, including the kinds of types helper functions can take Resolve the bugs with nested conditionals Make it clearer Make the code prettier Optimize for the use cases we’ve run into in production—then we might be more comfortable opening it up to larger use Make sure the concept of sharing templates works and is really solid If you use Handlebars.scala or have any additional ideas for improvements, I’d love to hear them—just contact me via GitHub."><meta property="og:description" content="If you rely on SEO, which really means that you rely on robots, you still want client-side app experiences. Handlebars.scala can help you get there. Handlebars.scala—also known around Gilt Tech as Scandlebars, and sometimes Scandalbars—is a Scala implementation of Handlebars: an extension to and superset of the Mustache templating language. It began as an attempt to learn Scala and to experiment with Scala’s Parser Combinators in order to get Handlebars.js templates working in Scala. These days, it forms a critical part of our stack. The Genesis of Handlebars.scala At Gilt, we rely on SEO for a not-insignificant amount of revenue. This means that, at some point, a robot/crawler makes a request against Gilt’s server, and the server has to return HTML. This is how most web pages have been made. In recent years, the paradigm has shifted toward web applications that use client-side template rendering techniques—i.e., single-page apps. These applications are faster than the old technologies allowed, and offer a snappier user experience. The idea behind a single-page app is that you can offload much of the HTML rendering to the client—and you do that through a templating language. Handlebars is one of those templating languages. At Gilt, we were trying to solve two problems: to render HTML pages server-side, but also get rich client-side rendering—a “best of both worlds” scenario to address the client-server disparity, and create a way to easily share UI pieces as a JVM library. We had experience with server-side templating engines like Java Server Pages (JSP), which has its own nuances, as well as client-side, JavaScript templating engines like Handlebars. With both of these, you end up duplicating logic—and our goal was to economize on server-side rendering and reduce the duplication. Our question: How can we make server-side rendering low-barrier enough without duplicating too much of our efforts in client-side rendering? We Tried Mustache With this question in mind, we checked out Mustache. A logic-less templating language, Mustache offers a considerable benefit: It’s language-agnostic and offers several implementations for all programming languages, including Scala. After experimenting with Mustache, however, our UI Architecture team realized that it’s really terse. Because of its logic-lessness, Mustache is kind of a pain in the ass to write (or can be, for something as large as an ecommerce site with millions of members). After playing around with Mustache, Eric and the team were drawn to Handlebars: a superset of Mustache created by Tilde co-founder Yehuda Katz. Handlebars is very similar to Mustache, but offers a variety of extras—namely, path lookups and helper functions. It also can be pre-compiled into JavaScript. Handlebars is a crucial component of Ember.js, which Yehuda also created. Our issue with Handlebars was that we needed it to run on the JVM. When I shared this info with Yehuda’s colleague, Tilde co-founder Tom Dale, after a NYC.JS meetup, he suggested that we try out Rhino—a JavaScript interpreter written in Java. At the time, Gilt Senior Engineer Kevan Davis was trying to figure out how to run Handlebars and Rhino, and made some progress with it, but the setup was clumsy because Rhino is clumsy. “Maybe I’ll just write Handlebars in Scala,” I finally said to Tom. We were at a bar at the time, and I was a bit tipsy, but there was a “yeah, sure, do that” vibe to our conversation. The Scandal of Scandlebars: I Didn’t Actually Know Scala Yet The problem with “just writing Handlebars in Scala” was that I hadn’t messed around with Scala much. Handlebars.scala was my first Scala project. Developing it was something of an excuse to play with the language and learn it by doing. Whatever works, right? The Scala standard library includes Parser Combinators: a functional programming method to describe grammars for language. I learned how to use Parser Combinators, and how to build parsers, by studying the source code of Scalate (a set of templating languages in Scala, including Mustache). This, plus help from the denizens of Gilt’s Scala 2.9.1 chat room, helped me to create Handlebars.scala. Handlebars’ preference for JavaScript (a dynamically typed, prototype-based language with first-class functions) made writing it in Scala (a statically-typed, hybrid-oriented language) pretty interesting from a bridging-concepts perspective. There’s just all kinds of syntactic quirks with Scala—for example, [Option] and how to make Option—or any monad—work. In developing Handlebars.scala I faced a number of philosophical questions: How do you write idiomatic Scala and still have it make sense? How should Options work? How does the collection library work? How can you leverage case and pattern matching so that you can achieve what you want in Handlebars by using Scala that you’re already familiar with (the idea being that any Scala object should be able to fit into a Handlebars template)? How Handlebars.scala Works I think the key thing that makes Handlebars.scala work is the idea of view models. On the Scala side, in our server, are intelligent, intermediary layers that we can use to render a Scala/Handlebars template or serialized into JSON in order to render them using Handlebars.js. Here’s an example of the apply method of a Handlebars instance, which should be familiar to Scala fans. Apply takes an optional second argument: a Map of helper functions. The signature for apply looks like this: def apply[T](context: T, helpers: Map[String,Helper[T]] = Map.empty[String,Helper[T]]) A few things to note when using Handlebars.scala: Implicit conversions will not work in a template. Because Handlebars.scala makes heavy use of reflection. Bummer, I know. This leads me to… …Handlebars.scala makes heavy use of reflection. This means that there could be unexpected behavior. Method overloading will behave in bizarre ways. There is likely a performance penalty. I’m not sophisticated enough in the arts of the JVM to know the implications of this. How does Handlebars.scala perform? We’ve been using Scandlebars in production, and it’s become a crucial part of our rendering stack. We use it wherever we have a user interface that needs to be represented both the server and the client. Handlebars.scala gives us this choice to render it immediately or at a later date. Some specific examples of Handlebars.scala at Gilt: Our new unified nav (built entirely with Handlebars.scala) We have lots of small applications that don’t all use the same technologies, but we need them to be able to share a user interface as a library. Scandlebars enables us to make these HTML pieces as a library Our product detail pages Search With those last two items, the idea was that the same template we use to render a product on a server can be used to render it on the client. This reduces duplication by a not-inconsequential amount. What the client can do is say, “I know how to render this thing. Now, I know I’m not a robot—I’m a user using JavaScript—so instead of going back to the server for an HTML roundtrip, I can just go to the JSON.” The client-side app experience feels a lot faster with Handlebars.scala. We started to benchmark its performance and tried to find bottlenecks in rendering. Handlebars.scala uses a lot of reflection, so that can sometimes be a bit tricky in Scala or another statically-typed language. But overall, I think it performs pretty well. There’s always going to be an upper bound to its performance because it uses reflection. One key question I haven’t answered yet is this: When you use futures in Scala and Akka, and a Handlebars.scala template resolves that future, how do you organize your code before putting it into Handlebars.scala and make your data easily accessible through Handlebars.scala? Until I have a sure answer to that question, I don’t advise resolving futures inside of a template. Then we started trying to figure out, we have the ability to make an AST (abstract syntax stream) out of a template file. Now how do you take data and render a template. Need some way for the tree to be filled in. It raised a bunch of questions The Future of Handlebars.scala Gilt Software Engineer Chris “Chicks” Hicks and I have started working on the next version of Handlebars.scala—the idea being that Handlebars.js 1.0 has been released fairly recently, and now we want Handlebars.scala to meet it in terms of almost-compatibility. A key concern is how we can make using Handlebars.scala balance between feeling like the JavaScript-Handlebars but just as comfortable for Scala developers. If Handlebars.scala is too much like JavaScript, it won’t fit with the programming paradigm, but if it’s too much like Scala, then it will feel like it deviates too much from its original implementation. I have a few ideas: Make usability improvements, including the kinds of types helper functions can take Resolve the bugs with nested conditionals Make it clearer Make the code prettier Optimize for the use cases we’ve run into in production—then we might be more comfortable opening it up to larger use Make sure the concept of sharing templates works and is really solid If you use Handlebars.scala or have any additional ideas for improvements, I’d love to hear them—just contact me via GitHub."><link rel="canonical" href="https://saksdirect.github.io/hbc-tech-blog/2013-08-29-handlebars-scala-a-handlebars-for-scala.html"><meta property="og:url" content="https://saksdirect.github.io/hbc-tech-blog/2013-08-29-handlebars-scala-a-handlebars-for-scala.html"><meta property="og:site_name" content="HBC Tech"><meta property="og:type" content="article"><meta property="article:published_time" content="2013-08-29T15:59:00-05:00"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@"><meta name="twitter:creator" content="@HBC Tech"><script type="application/ld+json">{"name":null,"description":"If you rely on SEO, which really means that you rely on robots, you still want client-side app experiences. Handlebars.scala can help you get there. Handlebars.scala—also known around Gilt Tech as Scandlebars, and sometimes Scandalbars—is a Scala implementation of Handlebars: an extension to and superset of the Mustache templating language. It began as an attempt to learn Scala and to experiment with Scala’s Parser Combinators in order to get Handlebars.js templates working in Scala. These days, it forms a critical part of our stack. The Genesis of Handlebars.scala At Gilt, we rely on SEO for a not-insignificant amount of revenue. This means that, at some point, a robot/crawler makes a request against Gilt’s server, and the server has to return HTML. This is how most web pages have been made. In recent years, the paradigm has shifted toward web applications that use client-side template rendering techniques—i.e., single-page apps. These applications are faster than the old technologies allowed, and offer a snappier user experience. The idea behind a single-page app is that you can offload much of the HTML rendering to the client—and you do that through a templating language. Handlebars is one of those templating languages. At Gilt, we were trying to solve two problems: to render HTML pages server-side, but also get rich client-side rendering—a “best of both worlds” scenario to address the client-server disparity, and create a way to easily share UI pieces as a JVM library. We had experience with server-side templating engines like Java Server Pages (JSP), which has its own nuances, as well as client-side, JavaScript templating engines like Handlebars. With both of these, you end up duplicating logic—and our goal was to economize on server-side rendering and reduce the duplication. Our question: How can we make server-side rendering low-barrier enough without duplicating too much of our efforts in client-side rendering? We Tried Mustache With this question in mind, we checked out Mustache. A logic-less templating language, Mustache offers a considerable benefit: It’s language-agnostic and offers several implementations for all programming languages, including Scala. After experimenting with Mustache, however, our UI Architecture team realized that it’s really terse. Because of its logic-lessness, Mustache is kind of a pain in the ass to write (or can be, for something as large as an ecommerce site with millions of members). After playing around with Mustache, Eric and the team were drawn to Handlebars: a superset of Mustache created by Tilde co-founder Yehuda Katz. Handlebars is very similar to Mustache, but offers a variety of extras—namely, path lookups and helper functions. It also can be pre-compiled into JavaScript. Handlebars is a crucial component of Ember.js, which Yehuda also created. Our issue with Handlebars was that we needed it to run on the JVM. When I shared this info with Yehuda’s colleague, Tilde co-founder Tom Dale, after a NYC.JS meetup, he suggested that we try out Rhino—a JavaScript interpreter written in Java. At the time, Gilt Senior Engineer Kevan Davis was trying to figure out how to run Handlebars and Rhino, and made some progress with it, but the setup was clumsy because Rhino is clumsy. “Maybe I’ll just write Handlebars in Scala,” I finally said to Tom. We were at a bar at the time, and I was a bit tipsy, but there was a “yeah, sure, do that” vibe to our conversation. The Scandal of Scandlebars: I Didn’t Actually Know Scala Yet The problem with “just writing Handlebars in Scala” was that I hadn’t messed around with Scala much. Handlebars.scala was my first Scala project. Developing it was something of an excuse to play with the language and learn it by doing. Whatever works, right? The Scala standard library includes Parser Combinators: a functional programming method to describe grammars for language. I learned how to use Parser Combinators, and how to build parsers, by studying the source code of Scalate (a set of templating languages in Scala, including Mustache). This, plus help from the denizens of Gilt’s Scala 2.9.1 chat room, helped me to create Handlebars.scala. Handlebars’ preference for JavaScript (a dynamically typed, prototype-based language with first-class functions) made writing it in Scala (a statically-typed, hybrid-oriented language) pretty interesting from a bridging-concepts perspective. There’s just all kinds of syntactic quirks with Scala—for example, [Option] and how to make Option—or any monad—work. In developing Handlebars.scala I faced a number of philosophical questions: How do you write idiomatic Scala and still have it make sense? How should Options work? How does the collection library work? How can you leverage case and pattern matching so that you can achieve what you want in Handlebars by using Scala that you’re already familiar with (the idea being that any Scala object should be able to fit into a Handlebars template)? How Handlebars.scala Works I think the key thing that makes Handlebars.scala work is the idea of view models. On the Scala side, in our server, are intelligent, intermediary layers that we can use to render a Scala/Handlebars template or serialized into JSON in order to render them using Handlebars.js. Here’s an example of the apply method of a Handlebars instance, which should be familiar to Scala fans. Apply takes an optional second argument: a Map of helper functions. The signature for apply looks like this: def apply[T](context: T, helpers: Map[String,Helper[T]] = Map.empty[String,Helper[T]]) A few things to note when using Handlebars.scala: Implicit conversions will not work in a template. Because Handlebars.scala makes heavy use of reflection. Bummer, I know. This leads me to… …Handlebars.scala makes heavy use of reflection. This means that there could be unexpected behavior. Method overloading will behave in bizarre ways. There is likely a performance penalty. I’m not sophisticated enough in the arts of the JVM to know the implications of this. How does Handlebars.scala perform? We’ve been using Scandlebars in production, and it’s become a crucial part of our rendering stack. We use it wherever we have a user interface that needs to be represented both the server and the client. Handlebars.scala gives us this choice to render it immediately or at a later date. Some specific examples of Handlebars.scala at Gilt: Our new unified nav (built entirely with Handlebars.scala) We have lots of small applications that don’t all use the same technologies, but we need them to be able to share a user interface as a library. Scandlebars enables us to make these HTML pieces as a library Our product detail pages Search With those last two items, the idea was that the same template we use to render a product on a server can be used to render it on the client. This reduces duplication by a not-inconsequential amount. What the client can do is say, “I know how to render this thing. Now, I know I’m not a robot—I’m a user using JavaScript—so instead of going back to the server for an HTML roundtrip, I can just go to the JSON.” The client-side app experience feels a lot faster with Handlebars.scala. We started to benchmark its performance and tried to find bottlenecks in rendering. Handlebars.scala uses a lot of reflection, so that can sometimes be a bit tricky in Scala or another statically-typed language. But overall, I think it performs pretty well. There’s always going to be an upper bound to its performance because it uses reflection. One key question I haven’t answered yet is this: When you use futures in Scala and Akka, and a Handlebars.scala template resolves that future, how do you organize your code before putting it into Handlebars.scala and make your data easily accessible through Handlebars.scala? Until I have a sure answer to that question, I don’t advise resolving futures inside of a template. Then we started trying to figure out, we have the ability to make an AST (abstract syntax stream) out of a template file. Now how do you take data and render a template. Need some way for the tree to be filled in. It raised a bunch of questions The Future of Handlebars.scala Gilt Software Engineer Chris “Chicks” Hicks and I have started working on the next version of Handlebars.scala—the idea being that Handlebars.js 1.0 has been released fairly recently, and now we want Handlebars.scala to meet it in terms of almost-compatibility. A key concern is how we can make using Handlebars.scala balance between feeling like the JavaScript-Handlebars but just as comfortable for Scala developers. If Handlebars.scala is too much like JavaScript, it won’t fit with the programming paradigm, but if it’s too much like Scala, then it will feel like it deviates too much from its original implementation. I have a few ideas: Make usability improvements, including the kinds of types helper functions can take Resolve the bugs with nested conditionals Make it clearer Make the code prettier Optimize for the use cases we’ve run into in production—then we might be more comfortable opening it up to larger use Make sure the concept of sharing templates works and is really solid If you use Handlebars.scala or have any additional ideas for improvements, I’d love to hear them—just contact me via GitHub.","author":{"@type":"Person","name":"HBC Tech"},"@type":"BlogPosting","url":"https://saksdirect.github.io/hbc-tech-blog/2013-08-29-handlebars-scala-a-handlebars-for-scala.html","publisher":null,"image":null,"headline":"Handlebars.scala: A Handlebars for Scala","dateModified":"2013-08-29T15:59:00-05:00","datePublished":"2013-08-29T15:59:00-05:00","sameAs":null,"mainEntityOfPage":{"@type":"WebPage","@id":"https://saksdirect.github.io/hbc-tech-blog/2013-08-29-handlebars-scala-a-handlebars-for-scala.html"},"@context":"http://schema.org"}</script><link rel="stylesheet" href="https://saksdirect.github.io/hbc-tech-blog/assets/css/main.css"><link rel="canonical" href="https://saksdirect.github.io/hbc-tech-blog/2013-08-29-handlebars-scala-a-handlebars-for-scala.html"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,700" rel="stylesheet"><link rel="shortcut icon" href="https://saksdirect.github.io/hbc-tech-blog/assets/images/favicon.ico"></head><body aria-label="Content"><header id="site-header" class="site-header"><div class="site-header__inner"><a class="site-header__logo" href="https://saksdirect.github.io/hbc-tech-blog/"><svg class="hbc-tech-logo" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 64 52"><use class="hbc-tech-logo__text" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#hbc-tech-logo"></use></svg></a><nav id="menu" class="navigation"><svg class="navigation__menu-icon" xmlns="http://www.w3.org/2000/svg"><path class="bar bar__top" d="M0,3 L30,3"></path><path class="bar bar__cross-1" d="M0,14 L30,14"></path><path class="bar bar__cross-2" d="M0,14 L30,14"></path><path class="bar bar__bottom" d="M0,25 L30,25"></path></svg><menu class="menu"><ul class="link-list"><li class="link-list__link-item"><a href="https://saksdirect.github.io/hbc-tech-blog/" class="link-list__link"><span class="link-list__link-highlight">Insights</span></a></li><li class="link-list__link-item"><a href="https://saksdirect.github.io/hbc-tech-blog/code" class="link-list__link"><span class="link-list__link-highlight">Code</span></a></li><li class="link-list__link-item"><a href="https://saksdirect.github.io/hbc-tech-blog/about" class="link-list__link"><span class="link-list__link-highlight">About</span></a></li><li class="link-list__link-item"><a href="https://saksdirect.github.io/hbc-tech-blog/work-here" class="link-list__link"><span class="link-list__link-highlight">Work Here</span></a></li></ul></menu></nav><search id="header-search" class="header-search"><form class="header-search__form"><input type="text" class="header-search__input" id="header-search-input" placeholder="Search" name="query"></form><svg id="header-search__toggle" class="header-search__svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 64 52"><use class="header-search__icon" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#search"></use></svg><section class="header-search__results" id="header-search__results"></section></search></div></header><section class="content"><article class="article"><header class="article__header article__header--reveal"><h1 class="header-title" title="Handlebars.scala: A Handlebars for Scala">Handlebars.scala: A Handlebars for Scala</h1><span id="no-image-placeholder" class="no-image-placeholder"></span> <span class="slug-divider"></span> <span class="article-meta__author"><a class="article-meta__author__link" href="https://saksdirect.github.io/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="article-meta__date">AUG 29, 2013</span></header><section class="article__content article__content--reveal"><div class="article__content__read-time"><span class="read-time" title="Estimated read time"><span class="read-time__text-1">8 min</span> <span class="read-time__text-2">Read</span> <span class="read-time__text-3">Time</span></span></div><div class="article__content__share-buttons"><ul class="share-buttons"><li class="share-buttons__link-item"><a href="https://twitter.com/intent/tweet?text=https://saksdirect.github.io/hbc-tech-blog//2013-08-29-handlebars-scala-a-handlebars-for-scala.html" class="share-buttons__link" title="Share on Twitter" target="_blank"><svg class="hbc-svg-icon" height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon--twitter" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#twitter"></use></svg></a></li><li class="share-buttons__link-item"><a href="https://www.linkedin.com/shareArticle?mini=true&url=https://saksdirect.github.io/hbc-tech-blog/&source=/2013-08-29-handlebars-scala-a-handlebars-for-scala.html&title=Handlebars.scala: A Handlebars for Scala" class="share-buttons__link" title="Share on Linkedin" target="_blank"><svg height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#linkedin"></use></svg></a></li><li class="share-buttons__link-item"><a href="https://www.facebook.com/sharer/sharer.php?u=https://saksdirect.github.io/hbc-tech-blog//2013-08-29-handlebars-scala-a-handlebars-for-scala.html" class="share-buttons__link" title="Share on Facebook" target="_blank"><svg height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#facebook"></use></svg></a></li><li class="share-buttons__link-item"><a href="https://www.reddit.com/submit?url=https://saksdirect.github.io/hbc-tech-blog//2013-08-29-handlebars-scala-a-handlebars-for-scala.html" class="share-buttons__link" title="Share on Reddit" target="_blank"><svg height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#reddit"></use></svg></a></li></ul></div><div class="article__content__body"><p>If you rely on SEO, which really means that you rely on robots, you still want client-side app experiences. <a href="https://github.com/mwunsch/handlebars.scala" target="_blank">Handlebars.scala</a> can help you get there. Handlebars.scala—also known around Gilt Tech as Scandlebars, and sometimes Scandalbars—is a Scala implementation of Handlebars: an extension to and superset of the Mustache templating language. It began as an attempt to learn Scala and to experiment with Scala’s Parser Combinators in order to get Handlebars.js templates working in Scala. These days, it forms a critical part of our stack.</p><h2>The Genesis of Handlebars.scala</h2><p>At Gilt, we rely on SEO for a not-insignificant amount of revenue. This means that, at some point, a robot/crawler makes a request against Gilt’s server, and the server has to return HTML. This is how most web pages have been made. In recent years, the paradigm has shifted toward web applications that use client-side template rendering techniques—i.e., single-page apps. These applications are faster than the old technologies allowed, and offer a snappier user experience. The idea behind a single-page app is that you can offload much of the HTML rendering to the client—and you do that through a templating language. Handlebars is one of those templating languages.</p><p>At Gilt, we were trying to solve two problems: to render HTML pages server-side, but also get rich client-side rendering—a “best of both worlds” scenario to address the client-server disparity, and create a way to easily share UI pieces as a JVM library.</p><p>We had experience with server-side templating engines like Java Server Pages (JSP), which has its own nuances, as well as client-side, JavaScript templating engines like Handlebars. With both of these, you end up duplicating logic—and our goal was to economize on server-side rendering and reduce the duplication. Our question: How can we make server-side rendering low-barrier enough without duplicating too much of our efforts in client-side rendering?</p><h2>We Tried Mustache</h2><p>With this question in mind, we checked out Mustache. A logic-less templating language, Mustache offers a considerable benefit: It’s language-agnostic and offers several implementations for all programming languages, including Scala. After experimenting with Mustache, however, our UI Architecture team realized that it’s really terse. Because of its logic-lessness, Mustache is kind of a pain in the ass to write (or can be, for something as large as an ecommerce site with millions of members).</p><p>After playing around with Mustache, Eric and the team were drawn to Handlebars: a superset of Mustache created by <a href="http://www.tilde.io/" target="_blank">Tilde</a> co-founder Yehuda Katz. Handlebars is very similar to Mustache, but offers a variety of extras—namely, path lookups and helper functions. It also can be pre-compiled into JavaScript. Handlebars is a crucial component of Ember.js, which Yehuda also created.</p><p>Our issue with Handlebars was that we needed it to run on the JVM. When I shared this info with Yehuda’s colleague, Tilde co-founder Tom Dale, after a <a href="http://www.meetup.com/NYC-JS/" target="_blank">NYC.JS</a> meetup, he suggested that we try out <a href="https://developer.mozilla.org/en-US/docs/Rhino" target="_blank">Rhino</a>—a JavaScript interpreter written in Java. At the time, Gilt Senior Engineer Kevan Davis was trying to figure out how to run Handlebars and Rhino, and made some progress with it, but the setup was clumsy because Rhino is clumsy. “Maybe I’ll just write Handlebars in Scala,” I finally said to Tom. We were at a bar at the time, and I was a bit tipsy, but there was a “yeah, sure, do that” vibe to our conversation.</p><h2>The Scandal of Scandlebars: I Didn’t Actually Know Scala Yet</h2><p>The problem with “just writing Handlebars in Scala” was that I hadn’t messed around with Scala much. Handlebars.scala was my first Scala project. Developing it was something of an excuse to play with the language and learn it by doing. Whatever works, right?</p><p>The Scala standard library includes Parser Combinators: a functional programming method to describe grammars for language. I learned how to use Parser Combinators, and how to build parsers, by studying the source code of Scalate (a set of templating languages in Scala, including Mustache). This, plus help from the denizens of Gilt’s Scala 2.9.1 chat room, helped me to create Handlebars.scala.</p><p>Handlebars’ preference for JavaScript (a dynamically typed, prototype-based language with first-class functions) made writing it in Scala (a statically-typed, hybrid-oriented language) pretty interesting from a bridging-concepts perspective. There’s just all kinds of syntactic quirks with Scala—for example, [Option] and how to make Option—or any monad—work.</p><p>In developing Handlebars.scala I faced a number of philosophical questions:</p><ul><li>How do you write idiomatic Scala and still have it make sense?</li><li>How should Options work?</li><li>How does the collection library work?</li><li>How can you leverage case and pattern matching so that you can achieve what you want in Handlebars by using Scala that you’re already familiar with (the idea being that any Scala object should be able to fit into a Handlebars template)?</li></ul><h2>How Handlebars.scala Works</h2><p>I think the key thing that makes Handlebars.scala work is the idea of view models. On the Scala side, in our server, are intelligent, intermediary layers that we can use to render a Scala/Handlebars template or serialized into JSON in order to render them using Handlebars.js.</p><p>Here’s an example of the apply method of a Handlebars instance, which should be familiar to Scala fans. Apply takes an optional second argument: a Map of helper functions. The signature for apply looks like this:</p><pre><code>def apply[T](context: T, helpers: Map[String,Helper[T]] = Map.empty[String,Helper[T]])</code></pre><h2>A few things to note when using Handlebars.scala:</h2><ul><li>Implicit conversions will not work in a template. Because Handlebars.scala makes heavy use of reflection. Bummer, I know. This leads me to…</li><li>…Handlebars.scala makes heavy use of reflection. This means that there could be unexpected behavior.</li><li>Method overloading will behave in bizarre ways.</li><li>There is likely a performance penalty. I’m not sophisticated enough in the arts of the JVM to know the implications of this.</li></ul><h2>How does Handlebars.scala perform?</h2><p>We’ve been using Scandlebars in production, and it’s become a crucial part of our rendering stack. We use it wherever we have a user interface that needs to be represented both the server and the client. Handlebars.scala gives us this choice to render it immediately or at a later date.</p><p>Some specific examples of Handlebars.scala at Gilt:</p><ul><li>Our new unified nav (built entirely with Handlebars.scala)</li><li>We have lots of small applications that don’t all use the same technologies, but we need them to be able to share a user interface as a library. Scandlebars enables us to make these HTML pieces as a library Our product detail pages Search</li></ul><p>With those last two items, the idea was that the same template we use to render a product on a server can be used to render it on the client. This reduces duplication by a not-inconsequential amount. What the client can do is say, “I know how to render this thing. Now, I know I’m not a robot—I’m a user using JavaScript—so instead of going back to the server for an HTML roundtrip, I can just go to the JSON.”</p><p>The client-side app experience feels a lot faster with Handlebars.scala. We started to benchmark its performance and tried to find bottlenecks in rendering. Handlebars.scala uses a lot of reflection, so that can sometimes be a bit tricky in Scala or another statically-typed language. But overall, I think it performs pretty well. There’s always going to be an upper bound to its performance because it uses reflection.</p><p>One key question I haven’t answered yet is this: When you use futures in Scala and Akka, and a Handlebars.scala template resolves that future, how do you organize your code before putting it into Handlebars.scala and make your data easily accessible through Handlebars.scala? Until I have a sure answer to that question, I don’t advise resolving futures inside of a template.</p><p>Then we started trying to figure out, we have the ability to make an AST (abstract syntax stream) out of a template file. Now how do you take data and render a template. Need some way for the tree to be filled in. It raised a bunch of questions</p><h2>The Future of Handlebars.scala</h2><p>Gilt Software Engineer Chris “Chicks” Hicks and I have started working on the next version of Handlebars.scala—the idea being that Handlebars.js 1.0 has been released fairly recently, and now we want Handlebars.scala to meet it in terms of almost-compatibility. A key concern is how we can make using Handlebars.scala balance between feeling like the JavaScript-Handlebars but just as comfortable for Scala developers. If Handlebars.scala is too much like JavaScript, it won’t fit with the programming paradigm, but if it’s too much like Scala, then it will feel like it deviates too much from its original implementation.</p><p>I have a few ideas:</p><ul><li>Make usability improvements, including the kinds of types helper functions can take</li><li>Resolve the bugs with nested conditionals</li><li>Make it clearer</li><li>Make the code prettier</li><li>Optimize for the use cases we’ve run into in production—then we might be more comfortable opening it up to larger use</li><li>Make sure the concept of sharing templates works and is really solid</li></ul><p>If you use Handlebars.scala or have any additional ideas for improvements, I’d love to hear them—just contact me <a href="https://github.com/mwunsch" target="_blank">via GitHub</a>.</p></div><footer class="article__content__footer"><div class="article-tags"><span class="article-tags__tag">Handlebars.Scala</span><span>,</span> <span class="article-tags__tag">Scandalbars</span><span>,</span> <span class="article-tags__tag">Handlebars.js</span><span>,</span> <span class="article-tags__tag">Ember.js</span><span>,</span> <span class="article-tags__tag">Tilde</span><span>,</span> <span class="article-tags__tag">Rhino</span><span>,</span> <span class="article-tags__tag">NYC.JS</span><span>,</span> <span class="article-tags__tag">parser combinators</span><span>,</span> <span class="article-tags__tag">Scala</span><span>,</span> <span class="article-tags__tag">Akka</span><span>,</span> <span class="article-tags__tag">open source</span><span>,</span> <span class="article-tags__tag">opensource</span></div><section class="author-bio"><svg class="author-bio__avatar" height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon hbc-svg-icon--avatar__circle" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#circle"></use><use class="hbc-svg-icon hbc-svg-icon--avatar__head" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#head"></use><use class="hbc-svg-icon hbc-svg-icon--avatar__body" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#body"></use></svg><p><a class="author-bio__link" href="https://saksdirect.github.io/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></p><p class="author-bio__bio">We power the website and mobile experiences for Saks, Saks Off Fifth, Gilt, Lord & Taylor and The Bay.</p></section></footer></section><aside class="recirc"><h2 class="header__title">Recent Insights</h2><span class="slug-divider"></span> <a class="header__view-all-link" href="https://saksdirect.github.io/hbc-tech-blog/categories/index.html">See All</a><div class="recirc__articles"><article class="recirc__articles__item"><section class="snippet"><h1 class="snippet__title"><a href="https://saksdirect.github.io/hbc-tech-blog/2017-12-30-presentations-we-love.html" class="snippet__title__link" title="Presentations we love: 2017">Presentations we love: 2017</a></h1><div class="snippet__meta"><a class="meta__category-link" href="https://saksdirect.github.io/hbc-tech-blog/categories/#presentations">presentations</a> <span class="slug-divider"></span> <span class="meta__author"><a class="meta__author-link" href="https://saksdirect.github.io/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="meta__date">DEC 30, 2017</span></div><a href="https://saksdirect.github.io/hbc-tech-blog/2017-12-30-presentations-we-love.html" class="snippet__excerpt__link" title="Presentations we love: 2017"><p class="snippet__excerpt">2017 was a year of growth and learning at HBC Tech. Our organization embraced new technologies and new ways of building application software.</p></a></section></article><article class="recirc__articles__item"><section class="snippet"><h1 class="snippet__title"><a href="https://saksdirect.github.io/hbc-tech-blog/2017-08-10-midyear-recap.html" class="snippet__title__link" title="HBC Tech Talks: February 2017 through July 2017">HBC Tech Talks: February 2017 through July 2017</a></h1><div class="snippet__meta"><a class="meta__category-link" href="https://saksdirect.github.io/hbc-tech-blog/category/events">events</a> <span class="slug-divider"></span> <span class="meta__author"><a class="meta__author-link" href="https://saksdirect.github.io/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="meta__date">AUG 10, 2017</span></div><a href="https://saksdirect.github.io/hbc-tech-blog/2017-08-10-midyear-recap.html" class="snippet__excerpt__link" title="HBC Tech Talks: February 2017 through July 2017"><p class="snippet__excerpt">We’ve had a busy 2017 at HBC. The great work of our teams has created opportunities to share what we’ve learned with audiences around the world. This year our folks have been on stage in Austin, Sydney, Portland, Seattle, San Diego, Boston, London, Israel and on our home turf in NYC and Dublin. The talks have covered deep learning, design thinking, data streaming and developer experience to name just a...</p></a></section></article><article class="recirc__articles__item"><section class="snippet"><h1 class="snippet__title"><a href="https://saksdirect.github.io/hbc-tech-blog/2017-06-29-open-source-friday.html" class="snippet__title__link" title="Open Source Friday">Open Source Friday</a></h1><div class="snippet__meta"><a class="meta__category-link" href="https://saksdirect.github.io/hbc-tech-blog/category/culture">culture</a> <span class="slug-divider"></span> <span class="meta__author"><a class="meta__author-link" href="https://saksdirect.github.io/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="meta__date">JUN 29, 2017</span></div><a href="https://saksdirect.github.io/hbc-tech-blog/2017-06-29-open-source-friday.html" class="snippet__excerpt__link" title="Open Source Friday"><p class="snippet__excerpt">From the 54 public repos maintained at code.gilt.com to the name of our tech blog (displayed in this tab’s header), open source has been part of our team’s DNA for years. Check out this blog post from 2015 if you’re not convinced.</p></a></section></article><article class="recirc__articles__item"><section class="snippet"><h1 class="snippet__title"><a href="https://saksdirect.github.io/hbc-tech-blog/2017-06-12-hbc-at-qcon.html" class="snippet__title__link" title="Hudson's Bay Company at QCon">Hudson's Bay Company at QCon</a></h1><div class="snippet__meta"><a class="meta__category-link" href="https://saksdirect.github.io/hbc-tech-blog/category/events">events</a> <span class="slug-divider"></span> <span class="meta__author"><a class="meta__author-link" href="https://saksdirect.github.io/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="meta__date">JUN 12, 2017</span></div><a href="https://saksdirect.github.io/hbc-tech-blog/2017-06-12-hbc-at-qcon.html" class="snippet__excerpt__link" title="Hudson's Bay Company at QCon"><p class="snippet__excerpt">Heading to QCon? Don’t miss these two sessions! If you can’t make it, stay tuned here for slides and recordings from the conference.</p></a></section></article></div></aside></article></section><footer class="footer"><svg class="est1670" xmlns="http://www.w3.org/2000/svg"><use class="hbc-tech-logo__use" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#est1670"></use></svg><section class="footer__links"><ul class="social-links social-links__list"><li class="social-links__list-item"><a class="social-links__link" target="_blank" rel="next" href="https://www.linkedin.com/company/hbc_digital/"><svg class="social-links__icon" xmlns="http://www.w3.org/2000/svg"><use class="linkedin" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#linkedin"></use></svg></a></li><li class="social-links__list-item"><a class="social-links__link" target="_blank" rel="next" href="https://twitter.com/hbcdigital/"><svg class="social-links__icon" xmlns="http://www.w3.org/2000/svg"><use class="twitter" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#twitter"></use></svg></a></li><li class="social-links__list-item"><a class="social-links__link" target="_blank" rel="next" href="https://www.instagram.com/hbcdigital"><svg class="social-links__icon" xmlns="http://www.w3.org/2000/svg"><use class="instagram" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://saksdirect.github.io/hbc-tech-blog/assets/images/hbc-icons.svg#instagram"></use></svg></a></li></ul><p class="copyright">&copy; 2018 HBC Tech</p></section></footer><script type="text/javascript" src="https://saksdirect.github.io/hbc-tech-blog/assets/js/vendor/scrollmagic/ScrollMagic.min.js"></script><script type="text/javascript" src="https://saksdirect.github.io/hbc-tech-blog/assets/js/vendor/jekyll-search-js/fetch.js"></script><script type="text/javascript" src="https://saksdirect.github.io/hbc-tech-blog/assets/js/vendor/jekyll-search-js/search.js"></script><script type="text/javascript" src="https://saksdirect.github.io/hbc-tech-blog/assets/js/main.js"></script></body></html>