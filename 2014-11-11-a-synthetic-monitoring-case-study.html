<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>A Synthetic Monitoring Case Study</title><title>A Synthetic Monitoring Case Study | HBC Tech</title><meta property="og:title" content="A Synthetic Monitoring Case Study"><meta name="author" content="HBC Tech"><meta property="og:locale" content="en_US"><meta name="description" content="Client-side web application monitoring comes in two main flavors. Real User Monitoring, or RUM, uses an agent that runs within each web page and reports on the page load data for every request. Typically, the browser’s performance timing API data is used. Gilt uses New Relic for RUM, and it provides a good overview of the application ecosystem. In the old forest/tree metaphor, it’s the forest. Synthetic monitoring does not run in the web application. Rather, synthetic monitoring vendors provide remote hardware that hits a web site periodically, and stores data for what it sees on that particular request. It’s “synthetic” because it’s not your users’ data; requests are made specifically for collecting data on your page loads. But it’s also controlled. The requests are made from predictable hardware over predictable connections. If RUM is the forest, synthetic monitoring is the trees. Gilt has been using Rigor for synthetic monitoring. It’s interesting to see how the data from each kind of monitoring provides a different perspective on the health of an application. Different Perspectives RUM collects data on every web request from every customer. So it’s big data, and our view of that data is going to be broad and not deep. For example, average page load times include every hit to the page, cached requests and uncached requests. These averages make it more difficult to see performance problems when they happen. The following is the performance of our sale listing page for a month in New Relic: Unlike RUM, synthetic monitoring is always dealing with a single uncached request from consistent hardware. This makes it much easier to see when a change affects performance. The following is a single request to the same sale listing page, for the same time period. Looks different, doesn’t it? There are obvious spikes and valleys. When we layer the two images on top of each other, we see that one really significant spike in the synthetic chart doesn’t even register on the RUM chart: So which type of monitoring should we use? The answer is YES. Both RUM and synthetic monitoring give different views of our performance, and are useful for different things. RUM helps us understand long-term trends, and synthetic monitoring helps us diagnose and solve shorter-term performance problems. Case Study Around October 1, I noticed an uptick in our sale listing page load time in Rigor. Incidentally, this is the same spike that above didn&rsquo;t really show up on the New Relic RUM chart. Looking through the git log of the repo, I didn’t see anything too suspicious. I then isolated the deployed git tag in which the change happened and performed a diff between that tag and the previous tag, comparing their frozen package.json files (containing the fully resolved AMD module versions). That showed a couple of possibilities, so I started looking into Rigor’s data. Synthetic monitoring tools generally give access to the waterfall charts for every page load. So, I isolated a few waterfalls prior to the uptick and a few following the uptick. What I found: an additional 25 images and a couple of additional requests. I was pretty sure I had my smoking gun. The culprit was most likely a new AMD module, called component.trending_products. Its job is to request products that our customers are currently buying in real time. This is a great feature for our customers, but at this point seemed to be adding upwards of a second of load time to our pages. Confirming the Suspicion Fortunately, synthetic monitoring is very good at showing us data around things even if customers are not seeing them. I was able to create an A/B test using our configuration service and use it to disable the feature for any visitor with a certain query parameter. This allowed me to run a synthetic test for a few days, which made it very clear this new feature was the problem. You can see that the lines move parallel to each other, with the only slight exception indicating a load time outlier that affected the average and 90%/95%/99% lines. Solving the Problem Fortunately, issues like these are relatively simple to improve. The first problem is the number of images. The component fetches JSON data from a service endpoint, runs it through a Handlebars template, and injects the resulting HTML into the page. The data source can contain any number of products to show to the user; typically around 25-30. But the product images are displayed in a carousel: As much as we’d like to tell ourselves otherwise, most users are not going to advance the carousel to look at additional products, so there’s really no need to load the image data for the images that are off-screen. This is easily accomplished with a template like this: &lt;img data-gilt-src=&quot;/path/to/image&quot; /&gt; This way, the image URI is in the rendered HTML. Of course, since none of the images have src attributes, I didn’t have any images showing on page load. The next step: activate the visible ones immediately after the template renders and is injected. (In the code below, the pageSize variable was created using window.matchMedia and was equal to the number of carousel items showing at each screen resolution.) target.find(&#39;img[data-gilt-src]&#39;).each(function (i) { if (i &lt; pageSize) { $(this).attr(&#39;src&#39;, $(this).attr(&#39;data-gilt-src&#39;)); $(this).removeAttr(&#39;data-gilt-src&#39;); } }); The images also were missing their quality parameter. We use a service provided by our CDN to compress our JPGs slightly, which saves roughly 30% on the file transfer. Adding ?oq=85 to the image immediately reduces the bandwidth going over the wire. Finally, I just needed a little bit of JavaScript to load additional images when the user interacts with the carousel. I was able to use our carousel’s API to do this (element is already in scope as the carousel container): carousel.subscribe(&#39;elementSwitched&#39;, function (data) { element.find(&#39;img[data-gilt-src]&#39;).each(function (i) { $(this).attr(&#39;src&#39;, $(this).attr(&#39;data-gilt-src&#39;)); $(this).removeAttr(&#39;data-gilt-src&#39;); }); } Loading all of the images at this point makes sense no matter how many carousel pages there are. By the time the user is interacting with the carousel, it’s a fairly safe assumption that the page is done loading and that there isn&rsquo;t too much other HTTP traffic. All these changes can&rsquo;t eliminate the load time involved in adding a new feature to a page. However, you can certainly tell from the chart below when the fixes were released, which is a continuation of the earlier chart showing just the A/B test variants. The decrease of all load times is actually unrelated; it&rsquo;s the coming together of the two lines, with and without the trending products feature, that shows the improvement. As time has passed, this new feature has settled into adding about 150ms to the page load, which is reasonable for the additional customer benefit it provides. Synthetic monitoring provides a perspective on your application that RUM can&rsquo;t. The controlled environment makes problems more visible, and also gives you the opportunity to test your hypotheses and make corrections without requiring customer traffic. This case study confirmed for us the usefulness of synthetic monitoring, and we&rsquo;re excited to integrate the tool into our workflow more in the future, including testing the performance of new features before we send customer traffic to them."><meta property="og:description" content="Client-side web application monitoring comes in two main flavors. Real User Monitoring, or RUM, uses an agent that runs within each web page and reports on the page load data for every request. Typically, the browser’s performance timing API data is used. Gilt uses New Relic for RUM, and it provides a good overview of the application ecosystem. In the old forest/tree metaphor, it’s the forest. Synthetic monitoring does not run in the web application. Rather, synthetic monitoring vendors provide remote hardware that hits a web site periodically, and stores data for what it sees on that particular request. It’s “synthetic” because it’s not your users’ data; requests are made specifically for collecting data on your page loads. But it’s also controlled. The requests are made from predictable hardware over predictable connections. If RUM is the forest, synthetic monitoring is the trees. Gilt has been using Rigor for synthetic monitoring. It’s interesting to see how the data from each kind of monitoring provides a different perspective on the health of an application. Different Perspectives RUM collects data on every web request from every customer. So it’s big data, and our view of that data is going to be broad and not deep. For example, average page load times include every hit to the page, cached requests and uncached requests. These averages make it more difficult to see performance problems when they happen. The following is the performance of our sale listing page for a month in New Relic: Unlike RUM, synthetic monitoring is always dealing with a single uncached request from consistent hardware. This makes it much easier to see when a change affects performance. The following is a single request to the same sale listing page, for the same time period. Looks different, doesn’t it? There are obvious spikes and valleys. When we layer the two images on top of each other, we see that one really significant spike in the synthetic chart doesn’t even register on the RUM chart: So which type of monitoring should we use? The answer is YES. Both RUM and synthetic monitoring give different views of our performance, and are useful for different things. RUM helps us understand long-term trends, and synthetic monitoring helps us diagnose and solve shorter-term performance problems. Case Study Around October 1, I noticed an uptick in our sale listing page load time in Rigor. Incidentally, this is the same spike that above didn&rsquo;t really show up on the New Relic RUM chart. Looking through the git log of the repo, I didn’t see anything too suspicious. I then isolated the deployed git tag in which the change happened and performed a diff between that tag and the previous tag, comparing their frozen package.json files (containing the fully resolved AMD module versions). That showed a couple of possibilities, so I started looking into Rigor’s data. Synthetic monitoring tools generally give access to the waterfall charts for every page load. So, I isolated a few waterfalls prior to the uptick and a few following the uptick. What I found: an additional 25 images and a couple of additional requests. I was pretty sure I had my smoking gun. The culprit was most likely a new AMD module, called component.trending_products. Its job is to request products that our customers are currently buying in real time. This is a great feature for our customers, but at this point seemed to be adding upwards of a second of load time to our pages. Confirming the Suspicion Fortunately, synthetic monitoring is very good at showing us data around things even if customers are not seeing them. I was able to create an A/B test using our configuration service and use it to disable the feature for any visitor with a certain query parameter. This allowed me to run a synthetic test for a few days, which made it very clear this new feature was the problem. You can see that the lines move parallel to each other, with the only slight exception indicating a load time outlier that affected the average and 90%/95%/99% lines. Solving the Problem Fortunately, issues like these are relatively simple to improve. The first problem is the number of images. The component fetches JSON data from a service endpoint, runs it through a Handlebars template, and injects the resulting HTML into the page. The data source can contain any number of products to show to the user; typically around 25-30. But the product images are displayed in a carousel: As much as we’d like to tell ourselves otherwise, most users are not going to advance the carousel to look at additional products, so there’s really no need to load the image data for the images that are off-screen. This is easily accomplished with a template like this: &lt;img data-gilt-src=&quot;/path/to/image&quot; /&gt; This way, the image URI is in the rendered HTML. Of course, since none of the images have src attributes, I didn’t have any images showing on page load. The next step: activate the visible ones immediately after the template renders and is injected. (In the code below, the pageSize variable was created using window.matchMedia and was equal to the number of carousel items showing at each screen resolution.) target.find(&#39;img[data-gilt-src]&#39;).each(function (i) { if (i &lt; pageSize) { $(this).attr(&#39;src&#39;, $(this).attr(&#39;data-gilt-src&#39;)); $(this).removeAttr(&#39;data-gilt-src&#39;); } }); The images also were missing their quality parameter. We use a service provided by our CDN to compress our JPGs slightly, which saves roughly 30% on the file transfer. Adding ?oq=85 to the image immediately reduces the bandwidth going over the wire. Finally, I just needed a little bit of JavaScript to load additional images when the user interacts with the carousel. I was able to use our carousel’s API to do this (element is already in scope as the carousel container): carousel.subscribe(&#39;elementSwitched&#39;, function (data) { element.find(&#39;img[data-gilt-src]&#39;).each(function (i) { $(this).attr(&#39;src&#39;, $(this).attr(&#39;data-gilt-src&#39;)); $(this).removeAttr(&#39;data-gilt-src&#39;); }); } Loading all of the images at this point makes sense no matter how many carousel pages there are. By the time the user is interacting with the carousel, it’s a fairly safe assumption that the page is done loading and that there isn&rsquo;t too much other HTTP traffic. All these changes can&rsquo;t eliminate the load time involved in adding a new feature to a page. However, you can certainly tell from the chart below when the fixes were released, which is a continuation of the earlier chart showing just the A/B test variants. The decrease of all load times is actually unrelated; it&rsquo;s the coming together of the two lines, with and without the trending products feature, that shows the improvement. As time has passed, this new feature has settled into adding about 150ms to the page load, which is reasonable for the additional customer benefit it provides. Synthetic monitoring provides a perspective on your application that RUM can&rsquo;t. The controlled environment makes problems more visible, and also gives you the opportunity to test your hypotheses and make corrections without requiring customer traffic. This case study confirmed for us the usefulness of synthetic monitoring, and we&rsquo;re excited to integrate the tool into our workflow more in the future, including testing the performance of new features before we send customer traffic to them."><link rel="canonical" href="https://tech.hbc.com/hbc-tech-blog/2014-11-11-a-synthetic-monitoring-case-study.html"><meta property="og:url" content="https://tech.hbc.com/hbc-tech-blog/2014-11-11-a-synthetic-monitoring-case-study.html"><meta property="og:site_name" content="HBC Tech"><meta property="og:type" content="article"><meta property="article:published_time" content="2014-11-11T17:16:10-05:00"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@"><meta name="twitter:creator" content="@HBC Tech"><script type="application/ld+json">{"name":null,"description":"Client-side web application monitoring comes in two main flavors. Real User Monitoring, or RUM, uses an agent that runs within each web page and reports on the page load data for every request. Typically, the browser’s performance timing API data is used. Gilt uses New Relic for RUM, and it provides a good overview of the application ecosystem. In the old forest/tree metaphor, it’s the forest. Synthetic monitoring does not run in the web application. Rather, synthetic monitoring vendors provide remote hardware that hits a web site periodically, and stores data for what it sees on that particular request. It’s “synthetic” because it’s not your users’ data; requests are made specifically for collecting data on your page loads. But it’s also controlled. The requests are made from predictable hardware over predictable connections. If RUM is the forest, synthetic monitoring is the trees. Gilt has been using Rigor for synthetic monitoring. It’s interesting to see how the data from each kind of monitoring provides a different perspective on the health of an application. Different Perspectives RUM collects data on every web request from every customer. So it’s big data, and our view of that data is going to be broad and not deep. For example, average page load times include every hit to the page, cached requests and uncached requests. These averages make it more difficult to see performance problems when they happen. The following is the performance of our sale listing page for a month in New Relic: Unlike RUM, synthetic monitoring is always dealing with a single uncached request from consistent hardware. This makes it much easier to see when a change affects performance. The following is a single request to the same sale listing page, for the same time period. Looks different, doesn’t it? There are obvious spikes and valleys. When we layer the two images on top of each other, we see that one really significant spike in the synthetic chart doesn’t even register on the RUM chart: So which type of monitoring should we use? The answer is YES. Both RUM and synthetic monitoring give different views of our performance, and are useful for different things. RUM helps us understand long-term trends, and synthetic monitoring helps us diagnose and solve shorter-term performance problems. Case Study Around October 1, I noticed an uptick in our sale listing page load time in Rigor. Incidentally, this is the same spike that above didn&rsquo;t really show up on the New Relic RUM chart. Looking through the git log of the repo, I didn’t see anything too suspicious. I then isolated the deployed git tag in which the change happened and performed a diff between that tag and the previous tag, comparing their frozen package.json files (containing the fully resolved AMD module versions). That showed a couple of possibilities, so I started looking into Rigor’s data. Synthetic monitoring tools generally give access to the waterfall charts for every page load. So, I isolated a few waterfalls prior to the uptick and a few following the uptick. What I found: an additional 25 images and a couple of additional requests. I was pretty sure I had my smoking gun. The culprit was most likely a new AMD module, called component.trending_products. Its job is to request products that our customers are currently buying in real time. This is a great feature for our customers, but at this point seemed to be adding upwards of a second of load time to our pages. Confirming the Suspicion Fortunately, synthetic monitoring is very good at showing us data around things even if customers are not seeing them. I was able to create an A/B test using our configuration service and use it to disable the feature for any visitor with a certain query parameter. This allowed me to run a synthetic test for a few days, which made it very clear this new feature was the problem. You can see that the lines move parallel to each other, with the only slight exception indicating a load time outlier that affected the average and 90%/95%/99% lines. Solving the Problem Fortunately, issues like these are relatively simple to improve. The first problem is the number of images. The component fetches JSON data from a service endpoint, runs it through a Handlebars template, and injects the resulting HTML into the page. The data source can contain any number of products to show to the user; typically around 25-30. But the product images are displayed in a carousel: As much as we’d like to tell ourselves otherwise, most users are not going to advance the carousel to look at additional products, so there’s really no need to load the image data for the images that are off-screen. This is easily accomplished with a template like this: &lt;img data-gilt-src=&quot;/path/to/image&quot; /&gt; This way, the image URI is in the rendered HTML. Of course, since none of the images have src attributes, I didn’t have any images showing on page load. The next step: activate the visible ones immediately after the template renders and is injected. (In the code below, the pageSize variable was created using window.matchMedia and was equal to the number of carousel items showing at each screen resolution.) target.find(&#39;img[data-gilt-src]&#39;).each(function (i) { if (i &lt; pageSize) { $(this).attr(&#39;src&#39;, $(this).attr(&#39;data-gilt-src&#39;)); $(this).removeAttr(&#39;data-gilt-src&#39;); } }); The images also were missing their quality parameter. We use a service provided by our CDN to compress our JPGs slightly, which saves roughly 30% on the file transfer. Adding ?oq=85 to the image immediately reduces the bandwidth going over the wire. Finally, I just needed a little bit of JavaScript to load additional images when the user interacts with the carousel. I was able to use our carousel’s API to do this (element is already in scope as the carousel container): carousel.subscribe(&#39;elementSwitched&#39;, function (data) { element.find(&#39;img[data-gilt-src]&#39;).each(function (i) { $(this).attr(&#39;src&#39;, $(this).attr(&#39;data-gilt-src&#39;)); $(this).removeAttr(&#39;data-gilt-src&#39;); }); } Loading all of the images at this point makes sense no matter how many carousel pages there are. By the time the user is interacting with the carousel, it’s a fairly safe assumption that the page is done loading and that there isn&rsquo;t too much other HTTP traffic. All these changes can&rsquo;t eliminate the load time involved in adding a new feature to a page. However, you can certainly tell from the chart below when the fixes were released, which is a continuation of the earlier chart showing just the A/B test variants. The decrease of all load times is actually unrelated; it&rsquo;s the coming together of the two lines, with and without the trending products feature, that shows the improvement. As time has passed, this new feature has settled into adding about 150ms to the page load, which is reasonable for the additional customer benefit it provides. Synthetic monitoring provides a perspective on your application that RUM can&rsquo;t. The controlled environment makes problems more visible, and also gives you the opportunity to test your hypotheses and make corrections without requiring customer traffic. This case study confirmed for us the usefulness of synthetic monitoring, and we&rsquo;re excited to integrate the tool into our workflow more in the future, including testing the performance of new features before we send customer traffic to them.","author":{"@type":"Person","name":"HBC Tech"},"@type":"BlogPosting","url":"https://tech.hbc.com/hbc-tech-blog/2014-11-11-a-synthetic-monitoring-case-study.html","publisher":null,"image":null,"headline":"A Synthetic Monitoring Case Study","dateModified":"2014-11-11T17:16:10-05:00","datePublished":"2014-11-11T17:16:10-05:00","sameAs":null,"mainEntityOfPage":{"@type":"WebPage","@id":"https://tech.hbc.com/hbc-tech-blog/2014-11-11-a-synthetic-monitoring-case-study.html"},"@context":"http://schema.org"}</script><link rel="stylesheet" href="https://tech.hbc.com/hbc-tech-blog/assets/css/main.css"><link rel="canonical" href="https://tech.hbc.com/hbc-tech-blog/2014-11-11-a-synthetic-monitoring-case-study.html"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,700" rel="stylesheet"><link rel="shortcut icon" href="https://tech.hbc.com/hbc-tech-blog/assets/images/favicon.ico"></head><body aria-label="Content"><header id="site-header" class="site-header"><div class="site-header__inner"><a class="site-header__logo" href="https://tech.hbc.com/hbc-tech-blog/"><svg class="hbc-tech-logo" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 64 52"><use class="hbc-tech-logo__text" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#hbc-tech-logo"></use></svg></a><nav id="menu" class="navigation"><svg class="navigation__menu-icon" xmlns="http://www.w3.org/2000/svg"><path class="bar bar__top" d="M0,3 L30,3"></path><path class="bar bar__cross-1" d="M0,14 L30,14"></path><path class="bar bar__cross-2" d="M0,14 L30,14"></path><path class="bar bar__bottom" d="M0,25 L30,25"></path></svg><menu class="menu"><ul class="link-list"><li class="link-list__link-item"><a href="https://tech.hbc.com/hbc-tech-blog/" class="link-list__link"><span class="link-list__link-highlight">Insights</span></a></li><li class="link-list__link-item"><a href="https://tech.hbc.com/hbc-tech-blog/code" class="link-list__link"><span class="link-list__link-highlight">Code</span></a></li><li class="link-list__link-item"><a href="https://tech.hbc.com/hbc-tech-blog/about" class="link-list__link"><span class="link-list__link-highlight">About</span></a></li><li class="link-list__link-item"><a href="https://tech.hbc.com/hbc-tech-blog/work-here" class="link-list__link"><span class="link-list__link-highlight">Work Here</span></a></li></ul></menu></nav><search id="header-search" class="header-search"><form class="header-search__form"><input type="text" class="header-search__input" id="header-search-input" placeholder="Search" name="query"></form><svg id="header-search__toggle" class="header-search__svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 64 52"><use class="header-search__icon" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#search"></use></svg><section class="header-search__results" id="header-search__results"></section></search></div></header><section class="content"><article class="article"><header class="article__header article__header--reveal"><h1 class="header-title" title="A Synthetic Monitoring Case Study">A Synthetic Monitoring Case Study</h1><span id="no-image-placeholder" class="no-image-placeholder"></span> <span class="slug-divider"></span> <span class="article-meta__author"><a class="article-meta__author__link" href="https://tech.hbc.com/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="article-meta__date">NOV 11, 2014</span></header><section class="article__content article__content--reveal"><div class="article__content__read-time"><span class="read-time" title="Estimated read time"><span class="read-time__text-1">6 min</span> <span class="read-time__text-2">Read</span> <span class="read-time__text-3">Time</span></span></div><div class="article__content__share-buttons"><ul class="share-buttons"><li class="share-buttons__link-item"><a href="https://twitter.com/intent/tweet?text=https://tech.hbc.com/hbc-tech-blog//2014-11-11-a-synthetic-monitoring-case-study.html" class="share-buttons__link" title="Share on Twitter" target="_blank"><svg class="hbc-svg-icon" height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon--twitter" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#twitter"></use></svg></a></li><li class="share-buttons__link-item"><a href="https://www.linkedin.com/shareArticle?mini=true&url=https://tech.hbc.com/hbc-tech-blog/&source=/2014-11-11-a-synthetic-monitoring-case-study.html&title=A Synthetic Monitoring Case Study" class="share-buttons__link" title="Share on Linkedin" target="_blank"><svg height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#linkedin"></use></svg></a></li><li class="share-buttons__link-item"><a href="https://www.facebook.com/sharer/sharer.php?u=https://tech.hbc.com/hbc-tech-blog//2014-11-11-a-synthetic-monitoring-case-study.html" class="share-buttons__link" title="Share on Facebook" target="_blank"><svg height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#facebook"></use></svg></a></li><li class="share-buttons__link-item"><a href="https://www.reddit.com/submit?url=https://tech.hbc.com/hbc-tech-blog//2014-11-11-a-synthetic-monitoring-case-study.html" class="share-buttons__link" title="Share on Reddit" target="_blank"><svg height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#reddit"></use></svg></a></li></ul></div><div class="article__content__body"><p>Client-side web application monitoring comes in two main flavors. Real User Monitoring, or RUM, uses an agent that runs within each web page and reports on the page load data for every request. Typically, the browser’s <a href="https://developer.mozilla.org/en-US/docs/Navigation_timing" target="_blank">performance timing API</a> data is used. Gilt uses <a href="http://newrelic.com/" target="_blank">New Relic</a> for RUM, and it provides a good overview of the application ecosystem. In the old forest/tree metaphor, it’s the forest.</p><p>Synthetic monitoring does not run in the web application. Rather, synthetic monitoring vendors provide remote hardware that hits a web site periodically, and stores data for what it sees on that particular request. It’s “synthetic” because it’s not your users’ data; requests are made specifically for collecting data on your page loads. But it’s also controlled. The requests are made from predictable hardware over predictable connections. If RUM is the forest, synthetic monitoring is the trees.</p><p>Gilt has been using <a href="http://rigor.com/" target="_blank">Rigor</a> for synthetic monitoring. It’s interesting to see how the data from each kind of monitoring provides a different perspective on the health of an application.</p><h3>Different Perspectives</h3><p>RUM collects data on every web request from every customer. So it’s big data, and our view of that data is going to be broad and not deep. For example, average page load times include every hit to the page, cached requests and uncached requests. These averages make it more difficult to see performance problems when they happen. The following is the performance of our <a href="http://www.gilt.com/sale/women" target="_blank">sale listing page</a> for a month in New Relic:</p><p><span id="docs-internal-guid-7b8c02fa-9fad-6ef9-17ae-376adb6bc441"><img alt="image" height="433px;" src="https://lh3.googleusercontent.com/zW2W7HePp9Kg8a_axD4WGfp0aG1ZOhJFUAA-5p8XXntDxrwrXglc-dp907zD2ROWb5PZxyMhyc5pp4IvEveQoHM8i_2P5dKfYKXHk6mne_uP_q7bkKhREbhSHkZss5mzuW9s" width="868px;"></span></p><p>Unlike RUM, synthetic monitoring is always dealing with a single uncached request from consistent hardware. This makes it much easier to see when a change affects performance. The following is a single request to the same sale listing page, for the same time period.</p><p><span id="docs-internal-guid-7b8c0301-9fae-2e1b-908e-43cbd8253947"><img alt="image" height="385px;" src="https://lh3.googleusercontent.com/SenGnoHAb38k5dOSqI-Yo9_o7R3NpV4dCmOpZ970WJWYXI0C58_IFwYeOWi_eeFIkUCMdyQJ2eVACEvgRcMQUM6I8DUFlLgW85FTvH3Z1rLf370jna2NleZgiNcIHcPLOUOX" width="885px;"></span></p><p>Looks different, doesn’t it? There are obvious spikes and valleys. When we layer the two images on top of each other, we see that one really significant spike in the synthetic chart doesn’t even register on the RUM chart:</p><p><span id="docs-internal-guid-7b8c03bc-9fae-66e0-3148-6c34db797111"><img alt="image" height="497px;" src="https://lh4.googleusercontent.com/zKYvzC3fsJ7BlOODcvQleqKKubNPywETmzZEZEStiZiRbLdybmC__6JlFDMP45c5TCFkVWWRbclXO5hK5GUpaNXlleFy37CRNHdJjniNgy5zfPTnX4agHX9sEKAzdNnNK4D6" width="910px;">So which type of monitoring should we use? The answer is YES. Both RUM and synthetic monitoring give different views of our performance, and are useful for different things. RUM helps us understand long-term trends, and synthetic monitoring helps us diagnose and solve shorter-term performance problems.</span></p><h3>Case Study</h3><p>Around October 1, I noticed an uptick in our sale listing page load time in Rigor. Incidentally, this is the same spike that above didn&rsquo;t really show up on the New Relic RUM chart.</p><p><span id="docs-internal-guid-7b8c031b-9fae-9f42-6814-f1ea69acaefb"><img alt="image" height="298px;" src="https://lh4.googleusercontent.com/M6Qkhe0LFFux7686noIwVSN86-siusqgw_VflTEjUbcYRsUABu3Wx-C_uFtyaNWlUTHN23ryxBPzWedkQHnnTjoH9XDXqHnGsMxXHGiZdr0OVuYBwNDv-MCVL5lag1GBkP6M" width="794px;"></span></p><p>Looking through the git log of the repo, I didn’t see anything too suspicious. I then isolated the deployed git tag in which the change happened and performed a diff between that tag and the previous tag, comparing their frozen package.json files (containing the fully resolved AMD module versions). That showed a couple of possibilities, so I started looking into Rigor’s data.</p><p>Synthetic monitoring tools generally give access to the waterfall charts for every page load. So, I isolated a few waterfalls prior to the uptick and a few following the uptick. What I found: an additional 25 images and a couple of additional requests. I was pretty sure I had my smoking gun.</p><p><span id="docs-internal-guid-7b8c0337-9fae-f1e0-f303-b7c1346ae248"><img alt="image" height="379px;" src="https://lh5.googleusercontent.com/Tnkb3L3yHIMH4CapIJpqASgKIj6z1tEaAGcdzy0XYTXK7r6xGo5BJVkIo2Q2Nngj7Zhx13deNOdopOnpuoS3LH344RcRya9XtrEr_Hvkc8kDoTV77rh1XFGQWz7xQIvLiXXP" width="686px;"></span></p><p>The culprit was most likely a new AMD module, called <code>component.trending_products</code>. Its job is to request products that our customers are currently buying in real time. This is a great feature for our customers, but at this point seemed to be adding upwards of a second of load time to our pages.</p><h3>Confirming the Suspicion</h3><p>Fortunately, synthetic monitoring is very good at showing us data around things even if customers are not seeing them. I was able to create an A/B test using our configuration service and use it to disable the feature for any visitor with a certain query parameter. This allowed me to run a synthetic test for a few days, which made it very clear this new feature was the problem. You can see that the lines move parallel to each other, with the only slight exception indicating a load time outlier that affected the average and 90%/95%/99% lines.</p><p><span id="docs-internal-guid-7b8c0359-9fc4-9010-1412-a01bc62cd3c8"><img alt="image" height="404px;" src="https://lh4.googleusercontent.com/LDTudKjWNCzKjbOdaiX-5HIvvkXu12ty5ILr2NHJ3vH1siln4S5BVokt5_xb2c2Bl8Ap2NvRmxQdxOUlidMwHRdpjY5QYIG9pByRstzYqkelAx-G8kO9bWohBnwOuIJAPHmT" width="859px;"></span></p><h3>Solving the Problem</h3><p>Fortunately, issues like these are relatively simple to improve.</p><p>The first problem is the number of images. The component fetches JSON data from a service endpoint, runs it through a Handlebars template, and injects the resulting HTML into the page. The data source can contain any number of products to show to the user; typically around 25-30. But the product images are displayed in a carousel:</p><p><span id="docs-internal-guid-7b8c0377-9faf-32cb-240e-5fc9a0143626"><img alt="image" height="496px;" src="https://lh3.googleusercontent.com/U-KatRLQchJhwDJ4HUGwQu2yevINTTElbZc5ULCfn-S4LY4aooTBXOBbrXDOdqmoNIZrQD7psjcFsL8aXyqVI5LnCvR9rAgdOieiNVcPaLG_x610JF2S70s72dobuUkPO6hA" width="741px;"></span></p><p>As much as we’d like to tell ourselves otherwise, most users are not going to advance the carousel to look at additional products, so there’s really no need to load the image data for the images that are off-screen. This is easily accomplished with a template like this:</p><pre>&lt;img data-gilt-src="/path/to/image" /&gt;</pre><p>This way, the image URI is in the rendered HTML. Of course, since none of the images have src attributes, I didn’t have any images showing on page load. The next step: activate the visible ones immediately after the template renders and is injected. (In the code below, the <code>pageSize</code> variable was created using <code>window.matchMedia</code> and was equal to the number of carousel items showing at each screen resolution.)</p><pre>target.find('img[data-gilt-src]').each(function (i) {
  if (i &lt; pageSize) {
    $(this).attr('src', $(this).attr('data-gilt-src'));
    $(this).removeAttr('data-gilt-src');
  }
});
</pre><p>The images also were missing their quality parameter. We use a service provided by our CDN to compress our JPGs slightly, which saves roughly 30% on the file transfer. Adding ?oq=85 to the image immediately reduces the bandwidth going over the wire.</p><p>Finally, I just needed a little bit of JavaScript to load additional images when the user interacts with the carousel. I was able to use our carousel’s API to do this (<code>element</code> is already in scope as the carousel container):</p><pre>carousel.subscribe('elementSwitched', function (data) {
  element.find('img[data-gilt-src]').each(function (i) {
    $(this).attr('src', $(this).attr('data-gilt-src'));
    $(this).removeAttr('data-gilt-src');
  });
}</pre><p>Loading all of the images at this point makes sense no matter how many carousel pages there are. By the time the user is interacting with the carousel, it’s a fairly safe assumption that the page is done loading and that there isn&rsquo;t too much other HTTP traffic.</p><p>All these changes can&rsquo;t eliminate the load time involved in adding a new feature to a page. However, you can certainly tell from the chart below when the fixes were released, which is a continuation of the earlier chart showing just the A/B test variants. The decrease of all load times is actually unrelated; it&rsquo;s the coming together of the two lines, with and without the trending products feature, that shows the improvement.</p><p><span id="docs-internal-guid-7b8c039b-9fb3-7a3a-888b-7642b74314ec"><img alt="image" height="394px;" src="https://lh4.googleusercontent.com/sQJSfH0e82d8g0TQSTSgp2sGBiI0ADGOf01fv7T64doWxqc4eLLUsIkXPM6lW1-zXIgVLVAJvKLi9dlhCJi--vFj7aVStATLo2TeD1nSUy5xI9mpKmmT14w68IN3N7Cna4Jk" width="858px;"></span></p><p><span>As time has passed, this new feature has settled into adding about 150ms to the page load, which is reasonable for the additional customer benefit it provides.</span></p><p><span>Synthetic monitoring provides a perspective on your application that RUM can&rsquo;t. The controlled environment makes problems more visible, and also gives you the opportunity to test your hypotheses and make corrections without requiring customer traffic. This case study confirmed for us the usefulness of synthetic monitoring, and we&rsquo;re excited to integrate the tool into our workflow more in the future, including testing the performance of new features before we send customer traffic to them.</span></p></div><footer class="article__content__footer"><div class="article-tags"><span class="article-tags__tag">eric shepherd</span><span>,</span> <span class="article-tags__tag">performance engineering</span><span>,</span> <span class="article-tags__tag">web performance</span><span>,</span> <span class="article-tags__tag">web perf</span><span>,</span> <span class="article-tags__tag">synthetic monitoring</span><span>,</span> <span class="article-tags__tag">Gilt</span><span>,</span> <span class="article-tags__tag">Gilt Groupe</span><span>,</span> <span class="article-tags__tag">Gilt Tech</span><span>,</span> <span class="article-tags__tag">gilttech</span><span>,</span> <span class="article-tags__tag">real user monitoring</span><span>,</span> <span class="article-tags__tag">RUM</span><span>,</span> <span class="article-tags__tag">client-side web application monitoring</span><span>,</span> <span class="article-tags__tag">New Relic</span><span>,</span> <span class="article-tags__tag">Rigor</span><span>,</span> <span class="article-tags__tag">big data</span><span>,</span> <span class="article-tags__tag">cached request</span><span>,</span> <span class="article-tags__tag">uncached request</span><span>,</span> <span class="article-tags__tag">component.trending_products</span><span>,</span> <span class="article-tags__tag">ab testing</span><span>,</span> <span class="article-tags__tag">a/b testing</span><span>,</span> <span class="article-tags__tag">JSON</span><span>,</span> <span class="article-tags__tag">HTML</span><span>,</span> <span class="article-tags__tag">Handlebars</span><span>,</span> <span class="article-tags__tag">JavaScript</span></div><section class="author-bio"><svg class="author-bio__avatar" height="36" width="36" xmlns="http://www.w3.org/2000/svg"><use class="hbc-svg-icon hbc-svg-icon--avatar__circle" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#circle"></use><use class="hbc-svg-icon hbc-svg-icon--avatar__head" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#head"></use><use class="hbc-svg-icon hbc-svg-icon--avatar__body" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#body"></use></svg><p><a class="author-bio__link" href="https://tech.hbc.com/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></p><p class="author-bio__bio">We power the website and mobile experiences for Saks, Saks Off Fifth, Gilt, Lord & Taylor and The Bay.</p></section></footer></section><aside class="recirc"><h2 class="header__title">Recent Insights</h2><span class="slug-divider"></span> <a class="header__view-all-link" href="https://tech.hbc.com/hbc-tech-blog/categories/index.html">See All</a><div class="recirc__articles"><article class="recirc__articles__item"><section class="snippet"><h1 class="snippet__title"><a href="https://tech.hbc.com/hbc-tech-blog/2017-12-30-presentations-we-love.html" class="snippet__title__link" title="Presentations we love: 2017">Presentations we love: 2017</a></h1><div class="snippet__meta"><a class="meta__category-link" href="https://tech.hbc.com/hbc-tech-blog/categories/#presentations">presentations</a> <span class="slug-divider"></span> <span class="meta__author"><a class="meta__author-link" href="https://tech.hbc.com/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="meta__date">DEC 30, 2017</span></div><a href="https://tech.hbc.com/hbc-tech-blog/2017-12-30-presentations-we-love.html" class="snippet__excerpt__link" title="Presentations we love: 2017"><p class="snippet__excerpt">2017 was a year of growth and learning at HBC Tech. Our organization embraced new technologies and new ways of building application software.</p></a></section></article><article class="recirc__articles__item"><section class="snippet"><h1 class="snippet__title"><a href="https://tech.hbc.com/hbc-tech-blog/2017-08-10-midyear-recap.html" class="snippet__title__link" title="HBC Tech Talks: February 2017 through July 2017">HBC Tech Talks: February 2017 through July 2017</a></h1><div class="snippet__meta"><a class="meta__category-link" href="https://tech.hbc.com/hbc-tech-blog/category/events">events</a> <span class="slug-divider"></span> <span class="meta__author"><a class="meta__author-link" href="https://tech.hbc.com/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="meta__date">AUG 10, 2017</span></div><a href="https://tech.hbc.com/hbc-tech-blog/2017-08-10-midyear-recap.html" class="snippet__excerpt__link" title="HBC Tech Talks: February 2017 through July 2017"><p class="snippet__excerpt">We’ve had a busy 2017 at HBC. The great work of our teams has created opportunities to share what we’ve learned with audiences around the world. This year our folks have been on stage in Austin, Sydney, Portland, Seattle, San Diego, Boston, London, Israel and on our home turf in NYC and Dublin. The talks have covered deep learning, design thinking, data streaming and developer experience to name just a...</p></a></section></article><article class="recirc__articles__item"><section class="snippet"><h1 class="snippet__title"><a href="https://tech.hbc.com/hbc-tech-blog/2017-06-29-open-source-friday.html" class="snippet__title__link" title="Open Source Friday">Open Source Friday</a></h1><div class="snippet__meta"><a class="meta__category-link" href="https://tech.hbc.com/hbc-tech-blog/category/culture">culture</a> <span class="slug-divider"></span> <span class="meta__author"><a class="meta__author-link" href="https://tech.hbc.com/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="meta__date">JUN 29, 2017</span></div><a href="https://tech.hbc.com/hbc-tech-blog/2017-06-29-open-source-friday.html" class="snippet__excerpt__link" title="Open Source Friday"><p class="snippet__excerpt">From the 54 public repos maintained at code.gilt.com to the name of our tech blog (displayed in this tab’s header), open source has been part of our team’s DNA for years. Check out this blog post from 2015 if you’re not convinced.</p></a></section></article><article class="recirc__articles__item"><section class="snippet"><h1 class="snippet__title"><a href="https://tech.hbc.com/hbc-tech-blog/2017-06-12-hbc-at-qcon.html" class="snippet__title__link" title="Hudson's Bay Company at QCon">Hudson's Bay Company at QCon</a></h1><div class="snippet__meta"><a class="meta__category-link" href="https://tech.hbc.com/hbc-tech-blog/category/events">events</a> <span class="slug-divider"></span> <span class="meta__author"><a class="meta__author-link" href="https://tech.hbc.com/hbc-tech-blog/authors/hbc-tech">HBC Tech</a></span> <span class="slug-divider"></span> <span class="meta__date">JUN 12, 2017</span></div><a href="https://tech.hbc.com/hbc-tech-blog/2017-06-12-hbc-at-qcon.html" class="snippet__excerpt__link" title="Hudson's Bay Company at QCon"><p class="snippet__excerpt">Heading to QCon? Don’t miss these two sessions! If you can’t make it, stay tuned here for slides and recordings from the conference.</p></a></section></article></div></aside></article></section><footer class="footer"><svg class="est1670" xmlns="http://www.w3.org/2000/svg"><use class="hbc-tech-logo__use" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#est1670"></use></svg><section class="footer__links"><ul class="social-links social-links__list"><li class="social-links__list-item"><a class="social-links__link" target="_blank" rel="next" href="https://www.linkedin.com/company/hbc_digital/"><svg class="social-links__icon" xmlns="http://www.w3.org/2000/svg"><use class="linkedin" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#linkedin"></use></svg></a></li><li class="social-links__list-item"><a class="social-links__link" target="_blank" rel="next" href="https://twitter.com/hbcdigital/"><svg class="social-links__icon" xmlns="http://www.w3.org/2000/svg"><use class="twitter" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#twitter"></use></svg></a></li><li class="social-links__list-item"><a class="social-links__link" target="_blank" rel="next" href="https://www.instagram.com/hbcdigital"><svg class="social-links__icon" xmlns="http://www.w3.org/2000/svg"><use class="instagram" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://tech.hbc.com/hbc-tech-blog/assets/images/hbc-icons.svg#instagram"></use></svg></a></li></ul><p class="copyright">&copy; 2018 HBC Tech</p></section></footer><script type="text/javascript" src="https://tech.hbc.com/hbc-tech-blog/assets/js/vendor/scrollmagic/ScrollMagic.min.js"></script><script type="text/javascript" src="https://tech.hbc.com/hbc-tech-blog/assets/js/vendor/jekyll-search-js/fetch.js"></script><script type="text/javascript" src="https://tech.hbc.com/hbc-tech-blog/assets/js/vendor/jekyll-search-js/search.js"></script><script type="text/javascript" src="https://tech.hbc.com/hbc-tech-blog/assets/js/main.js"></script></body></html>